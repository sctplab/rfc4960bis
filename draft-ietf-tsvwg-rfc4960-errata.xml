<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="2" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<?rfc strict="yes" ?>

<rfc category="info"
     ipr="trust200902"
     docName="draft-ietf-tsvwg-rfc4960-errata-02-to-be.txt">
<front>

<!--
ToDo
  * Limit SSN in flight to 2^16 - 1
  * Cleanup CRC32c code
  * Remove Hostname Parameter
  * Consider implications for the Supported Address Types Parameter
-->

<title>RFC 4960 Errata and Issues</title>

<!-- *************** RANDALL STEWART *************** -->
<author initials="R. R." surname="Stewart" fullname="Randall R. Stewart">
<organization>Netflix, Inc.</organization>
<address>
    <postal>
        <street></street>
        <city>Chapin</city>
        <region>SC</region>
        <code>29036</code>
        <country>United States</country>
    </postal>
    <email>randall@lakerest.net</email>
</address>
</author>

<!-- ************** MICHAEL TUEXEN *************** -->
<author initials="M." surname="Tuexen" fullname="Michael Tuexen">
<organization abbrev='Muenster Univ. of Appl. Sciences'>
              Muenster University of Applied Sciences</organization>
<address>
    <postal>
        <street>Stegerwaldstrasse 39</street>
        <city>48565 Steinfurt</city>
        <region/><code/>
        <country>Germany</country>
    </postal>
    <email>tuexen@fh-muenster.de</email>
</address>
</author>

<!-- ************** MAKSIM PROSHIN *************** -->
<author initials="M." surname="Proshin" fullname="Maksim Proshin">
<organization>Ericsson</organization>
<address>
    <postal>
        <street>Kistavaegen 25</street>
        <city>Stockholm</city>
        <code> 164 80</code>
        <country>Sweden</country>
    </postal>
    <email>mproshin@tieto.mera.ru</email>
</address>
</author>

<date />

<abstract>
<t>This document is a compilation of issues found since the publication of
RFC4960 in September 2007 based on experience with
implementing, testing, and using SCTP along with the suggested fixes.
This document provides deltas to RFC4960 and is organized in a time based way.
The issues are listed in the order they were brought up.
Because some text is changed several times the last delta in the text is the
one which should be applied.
In addition to the delta a description of the problem and the details of the
solution are also provided.</t>
</abstract>

</front>

<middle>

<section anchor='intro' title='Introduction'>
<t>This document contains a compilation of all defects found up until
the publishing of this document for <xref target="RFC4960"/> specifying the
Stream Control Transmission Protocol (SCTP).
These defects may be of an editorial or technical nature.
This document may be thought of as a companion document to be used in
the implementation of SCTP to clarify errors in the original SCTP document.</t>
<t>This document provides a history of the changes that will be compiled
into a BIS document for <xref target="RFC4960"/>. It is structured similar
to <xref target="RFC4460"/>.</t>

<t>Each error will be detailed within this document in the form of:
<list style='symbols'>
<t>The problem description,</t>
<t>The text quoted from <xref target="RFC4960"/>,</t>
<t>The replacement text that should be placed into an upcoming BIS document,</t>
<t>A description of the solution.</t>
</list></t>
<t>Note that when reading this document one must use care to assure that a field
or item is not updated further on within the document.
Each section should be applied in sequence to the original <xref target="RFC4960"/>
since this document is a historical record of the sequential changes that have
been found necessary at various inter-op events and through discussion on the
list.</t>
</section>

<section anchor='conventions' title='Conventions'>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>
</section>

<section title='Corrections to RFC 4960'>

<!-- Skeleton for an issue.
<section title='FIXME: Descriptive name of the issue'>
<section title='Description of the Problem'>
<t>FIXME</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
FIXME
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>FIXME</t>
</section>
</section>
-->

<!--
Current Erratas listed at
http://www.rfc-editor.org/errata_search.php?rfc=4960

* http://www.rfc-editor.org/errata_search.php?eid=1440 Verified
* http://www.rfc-editor.org/errata_search.php?eid=1574 Verified
* http://www.rfc-editor.org/errata_search.php?eid=2592 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3291 Held for Document Update
* http://www.rfc-editor.org/errata_search.php?eid=3423 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3788 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3804 Reported (Duplicate of 3291)
* http://www.rfc-editor.org/errata_search.php?eid=4071 Reported (Should be accepted)
* http://www.rfc-editor.org/errata_search.php?eid=4250 Reported (Should be rejected)
-->

<section title='Path Error Counter Threshold Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1440 -->

<section title='Description of the Problem'>
<t>The handling of the 'Path.Max.Retrans' parameter is described in
Section 8.2 and Section 8.3 of <xref target="RFC4960"/> in an Inconsistent
way. Whereas Section 8.2 describes that a path is marked inactive when
the path error counter exceeds the threshold, Section 8.3 says the path
is marked inactive when the path error counter reaches the threshold.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1440.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The intended state change should happen when the threshold is exceeded.</t>
</section>
</section>

<section title='Upper Layer Protocol Shutdown Request Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1574 -->
<section title='Description of the Problem'>
<t>Section 9.2 of <xref target="RFC4960"/> describes the handling of received
SHUTDOWN chunks in the SHUTDOWN-RECEIVED state instead of the handling of
shutdown requests from its upper layer in this state.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1574.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent SHUTDOWN chunks.

---------
New text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent ULP shutdown requests.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The text never intended the SCTP endpoint to ignore SHUTDOWN chunks from its
peer.
If it did the endpoints could never gracefully terminate associations in some
cases.</t>
</section>
</section>

<section title='Registration of New Chunk Types'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=2592 -->
<section title='Description of the Problem'>
<t>Section 14.1 of <xref target="RFC4960"/> should deal with new chunk types,
however, the text refers to parameter types.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 2592.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 14.1)
---------

The assignment of new chunk parameter type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk parameter MUST contain the following information:

---------
New text: (Section 14.1)
---------

The assignment of new chunk type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk type MUST contain the following information:
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Refer to chunk types as intended.</t>
</section>
</section>

<section title='Variable Parameters for INIT Chunks'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3291 -->
<!-- http://www.rfc-editor.org/errata_search.php?eid=3804 -->
<!-- The table was correctly formatted in RFC 2960 -->
<section title='Description of the Problem'>
<t>Newlines in wrong places break the layout of the table of variable
parameters for the INIT chunk in Section 3.3.2 of <xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3291 and Errata ID 3804.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5 IPv6 Address
(Note 1)               Optional    6 Cookie Preservative
Optional    9 Reserved for ECN Capable (Note 2)   Optional
32768 (0x8000) Host Name Address (Note 3)          Optional
11 Supported Address Types (Note 4)    Optional    12

---------
New text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5
IPv6 Address (Note 1)               Optional    6
Cookie Preservative                 Optional    9
Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)
Host Name Address (Note 3)          Optional    11
Supported Address Types (Note 4)    Optional    12
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Fix the formatting of the table.</t>
</section>
</section>

<section title='CRC32c Sample Code on 64-bit Platforms'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3423 -->
<section title='Description of the Problem'>
<t>The sample code for computing the CRC32c provided in <xref target="RFC4960"/>
assumes that a variable of type unsigned long uses 32 bits. This is not true
on some 64-bit platforms (for example the ones using LP64).</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3423.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = ~0L;

---------
New text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = 0xffffffffL;
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use 0xffffffffL instead of ~0L which gives the same value on platforms using
32 bits or 64 bits for variables of type unsigned long.</t>
</section>
</section>

<section anchor='endpoint_failure_detection'
         title='Endpoint Failure Detection'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3788 -->
<section title='Description of the Problem'>
<t>The handling of the association error counter defined in Section 8.1 of
<xref target="RFC4960"/> can result in an association failure even if the
path used for data transmission is available, but idle.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3788.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes retransmissions to all the
destination transport addresses of the peer if it is multi-homed),
including unacknowledged HEARTBEAT chunks.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>A more refined handling for the association error counter is defined.</t>
</section>
</section>

<section title='Data Transmission Rules'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4071 -->
<section title='Description of the Problem'>
<t>When integrating the changes to Section 6.1 A) of <xref target="RFC2960"/>
as described in Section 2.15.2 of <xref target="RFC4460"/> some text was
duplicated and became the final paragraph of Section 6.1 A) of
<xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4071.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1 A))
---------

The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].

However, regardless of the value of rwnd (including if it is 0),
the data sender can always have one DATA chunk in flight to the
receiver if allowed by cwnd (see rule B below).  This rule allows
the sender to probe for a change in rwnd that the sender missed
due to the SACK having been lost in transit from the data receiver
to the data sender.

---------
New text: (Section 6.1 A))
---------

The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Last paragraph of Section 6.1 A) removed as intended in Section 2.15.2 of
<xref target="RFC4460"/>.</t>
</section>
</section>

<section title='T1-Cookie Timer'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4400 -->
<section title='Description of the Problem'>
<t>Figure 4 of <xref target="RFC4960"/> illustrates the SCTP association setup.
However, it incorrectly shows that the T1-init timer is used in the
COOKIE-ECHOED state whereas the T1-cookie timer should have been used
instead.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4400.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-init timer)         \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-init timer, &lt;-----/
 Enter ESTABLISHED state)

---------
New text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-cookie timer)       \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-cookie timer, &lt;---/
 Enter ESTABLISHED state)
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Change the figure such that the T1-cookie timer is used instead of the
T1-init timer.</t>
</section>
</section>

<section title='Miscellaneous Typos'>
<section title='Description of the Problem'>
<t>While processing <xref target="RFC4960"/> some typos were not catched.</t>
</section>
<section title='Text Changes to the Document'>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2*32 - 1 is TSN = 0.

---------
New text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2**32 - 1 is TSN = 0.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a

DATA chunk if a received DATA chunk has no user data.

---------
New text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a
DATA chunk if a received DATA chunk has no user data.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z {App
sends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------
-----> (ack delayed) (Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Start=2,End=2]
                        &lt;-----/ (remove 6 from out-queue,
 and mark 7 as "1" missing report)

---------
New text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z
{App sends 3 messages; strm 0}
DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)
(Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Strt=2,End=2]
                        &lt;-----/
(remove 6 from out-queue,
 and mark 7 as "1" missing report)
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.10)
---------

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,

including the SCTP packet and IP headers, MUST be less that or equal
to the current Path MTU.

---------
New text: (Section 6.10)
---------

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,
including the SCTP packet and IP headers, MUST be less than or equal
to the current Path MTU.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------

o  Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

---------
New text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])
</artwork>
</figure>
<!-- The following was correct in RFC 4460 -->
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem",, or "Packet Too Big".

---------
New text: (Appendix C)
---------

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem", or "Packet Too Big".
</artwork>
</figure>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 5.4)
---------

2)  For the receiver of the COOKIE ECHO, the only CONFIRMED address
   is the one to which the INIT-ACK was sent.

---------
New text: (Section 5.4)
---------

2)  For the receiver of the COOKIE ECHO, the only CONFIRMED address
   is the one to which the INIT ACK was sent.
</artwork>
</figure>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-init timer)         \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-init timer, &lt;-----/
 Enter ESTABLISHED state)

---------
New text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-cookie timer)       \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE ACK
                              /
(Cancel T1-cookie timer, &lt;---/
 Enter ESTABLISHED state)
</artwork>
</figure>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 5.2.5)
---------

5.2.5.  Handle Duplicate COOKIE-ACK.

---------
New text: (Section 5.2.5)
---------

5.2.5.  Handle Duplicate COOKIE ACK.
</artwork>
</figure>
<!-- The following was already incorrect in RFC 4460 -->
<figure>
<artwork>
---------
Old text: (Section 8.3)
---------

By default, an SCTP endpoint SHOULD monitor the reachability of the
idle destination transport address(es) of its peer by sending a
HEARTBEAT chunk periodically to the destination transport
address(es).  HEARTBEAT sending MAY begin upon reaching the
ESTABLISHED state and is discontinued after sending either SHUTDOWN
or SHUTDOWN-ACK.  A receiver of a HEARTBEAT MUST respond to a
HEARTBEAT with a HEARTBEAT-ACK after entering the COOKIE-ECHOED state
(INIT sender) or the ESTABLISHED state (INIT receiver), up until
reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-
ACK-SENT state (SHUTDOWN receiver).

---------
New text: (Section 8.3)
---------
By default, an SCTP endpoint SHOULD monitor the reachability of the
idle destination transport address(es) of its peer by sending a
HEARTBEAT chunk periodically to the destination transport
address(es).  HEARTBEAT sending MAY begin upon reaching the
ESTABLISHED state and is discontinued after sending either SHUTDOWN
or SHUTDOWN ACK.  A receiver of a HEARTBEAT MUST respond to a
HEARTBEAT with a HEARTBEAT ACK after entering the COOKIE-ECHOED state
(INIT sender) or the ESTABLISHED state (INIT receiver), up until
reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-
ACK-SENT state (SHUTDOWN receiver).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Typos fixed.</t>
</section>
</section>

<section title='CRC32c Sample Code'>
<section title='Description of the Problem'>
<t>The CRC32c computation is described in Appendix B of <xref target="RFC4960"/>.
However, the corresponding sample code and its explanation appears at the end
of Appendix C, which deals with ICMP handling.</t>
</section>
<section title='Text Changes to the Document'>
<t>Move the sample code related to CRC32c computation and its explanation
from the end of Appendix C to the end of Appendix B.</t>
</section>
<section title='Solution Description'>
<t>Text moved to the appropriate location.</t>
</section>
</section>

<section title='partial_bytes_acked after T3-rtx Expiration'>
<!-- The following was correct in RFC 4460 -->
<section title='Description of the Problem'>
<t>Section 7.2.3 of <xref target="RFC4960"/> explicitly states that
partial_bytes_acked should be reset to 0 after packet loss detecting from SACK
but the same is missed for T3-rtx timer expiration.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU

---------
New text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU
partial_bytes_acked = 0
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Specify that partial_bytes_acked should be reset to 0 after T3-rtx timer
expiration.</t>
</section>
</section>

<section title='Order of Adjustments of partial_bytes_acked and cwnd'>
<!-- The correction is in accordance with RFC 3465, Section 2.1 -->
<section title='Description of the Problem'>
<t>Section 7.2.2 of <xref target="RFC4960"/> is unclear about the order
of adjustments applied to partial_bytes_acked and cwnd in the congestion
avoidance phase.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), increase cwnd by MTU, and
   reset partial_bytes_acked to (partial_bytes_acked - cwnd).

---------
New text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), partial_bytes_acked is reset
   to (partial_bytes_acked - cwnd). Next, cwnd is increased by MTU.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text defines the exact order of adjustments of
partial_bytes_acked and cwnd in the congestion avoidance phase.</t>
</section>
</section>

<section title='HEARTBEAT ACK and the association error counter'>
<section title='Description of the Problem'>
<t>Section 8.1 and Section 8.3 of <xref target="RFC4960"/>
prescribe that the receiver of a HEARTBEAT ACK must reset the
association overall error counter. In some circumstances, e.g.
when a router discards DATA chunks but not HEARTBEAT chunks due to
the larger size of the DATA chunk, it might be better to not clear
the association error counter on reception of the HEARTBEAT ACK and
reset it only on reception of the SACK to avoid stalling the
association.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK) or a HEARTBEAT
ACK is received from the peer endpoint.

---------
New text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK). When a
HEARTBEAT ACK is received from the peer endpoint, the counter should
also be reset. The receiver of the HEARTBEAT ACK may choose not to
clear the counter if there is outstanding data on the association.
This allows for handling the possible difference in reachability
based on DATA chunks and HEARTBEAT chunks.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text provides a possibility to not reset the association
overall error counter when a HEARTBEAT ACK is received if there are
valid reasons for it.</t>
</section>
</section>

<section title='Path for Fast Retransmission'>
<!-- The following was mentioned in RFC 4460, Section 2.39 -->
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> clearly describes where to retransmit
data that is timed out when the peer is multi-homed but the same
is not stated for fast retransmissions.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.4)
---------

Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

---------
New text: (Section 6.4)
---------


Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

When its peer is multi-homed, an endpoint SHOULD send fast
retransmissions to the same destination transport address where
original data was sent to. If the primary path has been changed and
original data was sent there before the fast retransmit, the
implementation MAY send it to the new primary path.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies where to send fast retransmissions.</t>
</section>
</section>

<section title='Transmittal in Fast Recovery'>
<section title='Description of the Problem'>
<t>The Fast Retransmit on Gap Reports algorithm intends that only the
very first packet may be sent regardless of cwnd in the Fast Recovery
phase but rule 3) of <xref target="RFC4960"/>, Section 7.2.4, misses
this clarification.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.4)
---------

3)  Determine how many of the earliest (i.e., lowest TSN) DATA chunks
    marked for retransmission will fit into a single packet, subject
    to constraint of the path MTU of the destination transport
    address to which the packet is being sent.  Call this value K.
    Retransmit those K DATA chunks in a single packet.  When a Fast
    Retransmit is being performed, the sender SHOULD ignore the value
    of cwnd and SHOULD NOT delay retransmission for this single
    packet.

---------
New text: (Section 7.2.4)
---------

3)  If not in Fast Recovery, determine how many of the earliest
    (i.e., lowest TSN) DATA chunks marked for retransmission will fit
    into a single packet, subject to constraint of the path MTU of
    the destination transport address to which the packet is being
    sent. Call this value K. Retransmit those K DATA chunks in a
    single packet. When a Fast Retransmit is being performed, the
    sender SHOULD ignore the value of cwnd and SHOULD NOT delay
    retransmission for this single packet.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text explicitly specifies to send only the first packet in
the Fast Recovery phase disregarding cwnd limitations.
</t>
</section>
</section>

<section title='Initial Value of ssthresh'>
<section title='Description of the Problem'>
<t>The initial value of ssthresh should be set arbitrarily high. Using
the advertised receiver window of the peer is inappropriate if the peer
increases its window after the handshake.
Furthermore, use a higher requirements level, since not following the advice
may result in performance problems.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial value of ssthresh MAY be arbitrarily high (for
   example, implementations MAY use the size of the receiver
   advertised window).

---------
New text: (Section 7.2.1)
---------

o  The initial value of ssthresh SHOULD be arbitrarily high (e.g.,
   to the size of the largest possible advertised window).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use the same value as suggested in <xref target="RFC5681"/>, Section 3.1,
as an appropriate initial value.
Furthermore use the same requirements level.</t>
</section>
</section>

<section title='Automatically Confirmed Addresses'>
<section title='Description of the Problem'>
<t>The Path Verification procedure of <xref target="RFC4960"/>
prescribes that any address passed to the sender of the INIT by its
upper layer is automatically CONFIRMED. This however is unclear if
only addresses in the request to initiate association establishment
are considered or any addresses provided by the upper layer in any
requests (e.g. in 'Set Primary').</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.4)
---------

1)  Any address passed to the sender of the INIT by its upper layer
   is automatically considered to be CONFIRMED.

---------
New text: (Section 5.4)
---------

1)  Any addresses passed to the sender of the INIT by its upper
   layer in the request to initialize an association is
   automatically considered to be CONFIRMED.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies that only addresses provided by the upper
layer in the request to initialize an association are automatically
confirmed.</t>
</section>
</section>

<section title='Only One Packet after Retransmission Timeout'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> is not completely clear when it describes data
transmission after T3-rtx timer expiration. Section 7.2.1 does not specify
how many packets are allowed to be sent after T3-rtx timer expiration if
more than one packet fit into cwnd. At the same time, Section 7.2.3 has the text
without normative language saying that SCTP should ensure that no more than one
packet will be in flight after T3-rtx timer expiration until successful
acknowledgment. It makes the text inconsistent.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial cwnd after a retransmission timeout MUST be no more
   than 1*MTU.

---------
New text: (Section 7.2.1)
---------

o  The initial cwnd after a retransmission timeout MUST be no more
   than 1*MTU and only one packet is allowed to be in flight
   until successful acknowledgement.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clearly specifies that only one packet is allowed to be
sent after T3-rtx timer expiration until successful acknowledgement.</t>
</section>
</section>

<section title='INIT ACK Path for INIT in COOKIE-WAIT State'>
<section title='Description of the Problem'>
<t>In case of an INIT received in the COOKIE-WAIT state
<xref target="RFC4960"/> prescribes to send an INIT ACK to the
same destination address to which the original INIT has been sent.
This text does not address the possibility of the upper layer to
provide multiple remote IP addresses while requesting the association
establishment. If the upper layer has provided multiple IP
addresses and only a subset of these addresses are supported by the
peer then the destination address of the original INIT may be
absent in the incoming INIT and sending INIT ACK to that address
is useless.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.2.1)
---------

Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST
respond with an INIT ACK using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged).  When
responding, the endpoint MUST send the INIT ACK back to the same
address that the original INIT (sent by this endpoint) was sent.

---------
New text: (Section 5.2.1)
---------

Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST
respond with an INIT ACK using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged). When
responding, the following rules MUST be applied:

1)  The INIT ACK MUST only be sent to an address passed by the upper
    layer in the request to initialize the association.

2)  The INIT ACK MUST only be sent to an address reported in the
    incoming INIT.

3)  The INIT ACK SHOULD be sent to the source address of the
    received INIT.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text requires sending INIT ACK to the destination address
that is passed by the upper layer and reported in the incoming INIT.
If the source address of the INIT fulfills it then sending the
INIT ACK to the source address of the INIT is the preferred behavior.</t>
</section>
</section>

<section title='Zero Window Probing and Unreachable Primary Path'>
<section title='Description of the Problem'>
<t>Section 6.1 of <xref target="RFC4960"/> states that when sending
zero window probes, SCTP should neither increment the association
counter nor increment the destination address error counter if it continues
to receive new packets from the peer. But receiving new packets
from the peer does not guarantee peer's accessibility and, if the
destination address becomes unreachable during zero window probing,
SCTP cannot get a changed rwnd until it switches the destination
address for probes.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1)
---------

If the sender continues to receive new packets from the receiver
while doing zero window probing, the unacknowledged window probes
should not increment the error counter for the association or any
destination transport address.  This is because the receiver MAY
keep its window closed for an indefinite time.  Refer to Section
6.2 on the receiver behavior when it advertises a zero window.

---------
New text: (Section 6.1)
---------

If the sender continues to receive SACKs from the peer
while doing zero window probing, the unacknowledged window probes
should not increment the error counter for the association or any
destination transport address.  This is because the receiver MAY
keep its window closed for an indefinite time.  Refer to Section
6.2 on the receiver behavior when it advertises a zero window.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies that if the receiver continues to send
SACKs, the sender of probes should not increment the error counter
of the association and the destination address even if the SACKs
do not acknowledge the probes.</t>
</section>
</section>

<section title='Normative Language in Section 10'>
<section title='Description of the Problem'>
<t>Section 10 of <xref target="RFC4960"/> is informative and normative language
such as MUST and MAY cannot be used there.
However, there are several places in Section 10 where MUST and MAY are used.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------

E) Send

 Format: SEND(association id, buffer address, byte count [,context]
         [,stream id] [,life time] [,destination transport address]
         [,unordered flag] [,no-bundle flag] [,payload protocol-id] )
 -> result

...

o  no-bundle flag - instructs SCTP not to bundle this user data with
   other outbound DATA chunks.  SCTP MAY still bundle even when this
   flag is present, when faced with network congestion.

---------
New text: (Section 10.1)
---------

E) Send

 Format: SEND(association id, buffer address, byte count [,context]
         [,stream id] [,life time] [,destination transport address]
         [,unordered flag] [,no-bundle flag] [,payload protocol-id] )
 -> result

...

o  no-bundle flag - instructs SCTP not to bundle this user data with
   other outbound DATA chunks.  SCTP may still bundle even when this
   flag is present, when faced with network congestion.

---------
Old text: (Section 10.1)
---------

G) Receive

 Format: RECEIVE(association id, buffer address, buffer size
         [,stream id])
 -> byte count [,transport address] [,stream id] [,stream sequence
    number] [,partial flag] [,delivery number] [,payload protocol-id]

...

o  partial flag - if this returned flag is set to 1, then this
   Receive contains a partial delivery of the whole message.  When
   this flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

G) Receive

 Format: RECEIVE(association id, buffer address, buffer size
         [,stream id])
 -> byte count [,transport address] [,stream id] [,stream sequence
    number] [,partial flag] [,delivery number] [,payload protocol-id]

...

o  partial flag - if this returned flag is set to 1, then this
   Receive contains a partial delivery of the whole message.  When
   this flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
Old text: (Section 10.1)
---------

N) Receive Unsent Message

   Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer
           size [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

N) Receive Unsent Message

   Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer
           size [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
Old text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The normative language is removed from Section 10.</t>
</section>
</section>

<section title='Increase of partial_bytes_acked in Congestion Avoidance'>
<section title='Description of the Problem'>
<t>Two issues have been discovered with the partial_bytes_acked handling
described in Section 7.2.2 of <xref target="RFC4960"/>:
<list style='symbols'>
<t>If the Cumulative TSN Ack Point is not advanced but the SACK chunk
acknowledges new TSNs in the Gap Ack Blocks, these newly acknowledged TSNs
are not considered for partial_bytes_acked although these TSNs were
successfully received by the peer.</t>
<t>Duplicate TSNs are not considered in partial_bytes_acked although
they confirm that the DATA chunks were successfully received by the peer.</t>
</list></t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival
   that advances the Cumulative TSN Ack Point, increase
   partial_bytes_acked by the total number of bytes of all new chunks
   acknowledged in that SACK including chunks acknowledged by the new
   Cumulative TSN Ack and by Gap Ack Blocks.

---------
New text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival,
   increase partial_bytes_acked by the total number of bytes of all
   new chunks acknowledged in that SACK including chunks acknowledged
   by the new Cumulative TSN Ack, by Gap Ack Blocks and by the number
   of bytes of duplicated chunks reported in Duplicate TSNs.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Now partial_bytes_acked is increased by TSNs reported as duplicated
as well as TSNs newly acknowledged in Gap Ack Blocks even if the
Cumulative TSN Ack Point is not advanced.</t>
</section>
</section>

<section title='Inconsistency in Notifications Handling'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> uses inconsistent normative and
non-normative language when describing rules for sending
notifications to the upper layer.
E.g. Section 8.2 of <xref target="RFC4960"/> says that when a destination
address becomes inactive due to an unacknowledged DATA chunk or HEARTBEAT chunk,
SCTP SHOULD send a notification to the upper layer while Section 8.3 of
<xref target="RFC4960"/> says that when a destination address becomes inactive
due to an unacknowledged HEARTBEAT chunk, SCTP may send a notification to the
upper layer.</t>
<t>This makes the text inconsistent.</t>
</section>
<section title='Text Changes to the Document'>
<t>The following cahnge is based on the change described in
<xref target='endpoint_failure_detection'/>.</t>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle). If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint MAY report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle). If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint SHOULD report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.
</artwork>
</figure>
<t>The following changes are based on <xref target='RFC4960'/>.</t>
<figure>
<artwork>
---------
Old text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent).  When the peer
endpoint is multi-homed and the last chunk sent to it was a
retransmission to an alternate address, there exists an ambiguity as
to whether or not the acknowledgement should be credited to the
address of the last chunk sent.  However, this ambiguity does not
seem to bear any significant consequence to SCTP behavior.  If this
ambiguity is undesirable, the transmitter may choose not to clear the
error counter if the last chunk sent was a retransmission.

---------
New text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent), and SHOULD
also report to the upper layer when an inactive destination address
is marked as active. When the peer endpoint is multi-homed and the
last chunk sent to it was a retransmission to an alternate address,
there exists an ambiguity as to whether or not the acknowledgement
should be credited to the address of the last chunk sent. However,
this ambiguity does not seem to bear any significant consequence to
SCTP behavior. If this ambiguity is undesirable, the transmitter may
choose not to clear the error counter if the last chunk sent was a
retransmission.

---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and SHOULD
also report to the upper layer the change of reachability of this
destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint SHOULD
report to the upper layer when an inactive destination address
is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).

---------
Old text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and MUST report the peer endpoint unreachable to the upper layer (and
thus the association enters the CLOSED state).

---------
New text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and SHOULD report the peer endpoint unreachable to the upper layer
(and thus the association enters the CLOSED state).

---------
Old text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'.  If this threshold is exceeded, the
endpoint should destroy the TCB and may report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).

---------
New text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'. If this threshold is exceeded, the
endpoint should destroy the TCB and SHOULD report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The inconsistencies are removed by using consistently SHOULD.</t>
</section>
</section>

<section title='SACK.Delay Not Listed as a Protocol Parameter'>
<section title='Description of the Problem'>
<t>SCTP as specified in <xref target='RFC4960'/> supports delaying SACKs.
The timer value for this is a parameter and Section 6.2 of
<xref target='RFC4960'/> specifies a default and maximum value for it.
However, defining a name for this parameter and listing it in the table
of protocol parameters in Section 15 of <xref target='RFC4960'/> is missing.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4656.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.2)
---------

An implementation MUST NOT allow the maximum delay to be configured
to be more than 500 ms.  In other words, an implementation MAY lower
this value below 500 ms but MUST NOT raise it above 500 ms.

---------
New text: (Section 6.2)
---------

An implementation MUST NOT allow the maximum delay (protocol
parameter 'SACK.Delay') to be configured to be more than 500 ms.
In other words, an implementation MAY lower the value of
SACK.Delay below 500 ms but MUST NOT raise it above 500 ms.

---------
Old text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 3 seconds
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1

---------
New text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 3 seconds
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1
   SACK.Delay - 200 milliseconds
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The parameter was given a name and added to the list of protocol
parameters.</t>
</section>
</section>

<section title='Processing of Chunks in an Incoming SCTP Packet'>
<section title='Description of the Problem'>
<t>There are a few places in <xref target='RFC4960'/> where the receiver of
a packet must discard it while processing the chunks of the packet.
It is unclear whether the receiver has to rollback state changes already
performed while processing the packet or not.</t>
<t>The intention of <xref target='RFC4960'/> is to process an incoming packet
chunk by chunk and do not perform any prescreening of chunks in the received
packet so the receiver must only discard a chunk causing discard and all further
chunks.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 3.2)
---------

00 -  Stop processing this SCTP packet and discard it, do not
      process any further chunks within it.

01 -  Stop processing this SCTP packet and discard it, do not
      process any further chunks within it, and report the
      unrecognized chunk in an 'Unrecognized Chunk Type'.

---------
New text: (Section 3.2)
---------

00 -  Stop processing this SCTP packet, discard the unrecognized
      chunk and all further chunks.

01 -  Stop processing this SCTP packet, discard the unrecognized
      chunk and all further chunks, and report the unrecognized
      chunk in an 'Unrecognized Chunk Type'.

---------
Old text: (Section 11.3)
---------

It is helpful for some firewalls if they can inspect just the first
fragment of a fragmented SCTP packet and unambiguously determine
whether it corresponds to an INIT chunk (for further information,
please refer to [RFC1858]).  Accordingly, we stress the requirements,
stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled
with any other chunk in a packet, and (2) a packet containing an INIT
chunk MUST have a zero Verification Tag.  Furthermore, we require
that the receiver of an INIT chunk MUST enforce these rules by
silently discarding an arriving packet  with an INIT chunk that is
bundled with other chunks or has a non-zero verification tag and
contains an INIT-chunk.

---------
New text: (Section 11.3)
---------

It is helpful for some firewalls if they can inspect just the first
fragment of a fragmented SCTP packet and unambiguously determine
whether it corresponds to an INIT chunk (for further information,
please refer to [RFC1858]).  Accordingly, we stress the requirements,
stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled
with any other chunk in a packet, and (2) a packet containing an INIT
chunk MUST have a zero Verification Tag.  Furthermore, we require
that the receiver of an INIT chunk MUST enforce these rules by
silently discarding the INIT chunk and all further chunks if the INIT
chunk is bundled with other chunks or the packet has a non-zero
verification tag.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text makes it clear that chunks can be processed from the beginning
to the end and no rollback or pre-screening is required.</t>
</section>
</section>

<section title='CWND Increase in Congestion Avoidance Phase'>
<section title='Description of the Problem'>
<t><xref target='RFC4960'/> in Section 7.2.2 prescribes to increase cwnd
by 1*MTU per RTT if the sender has cwnd or more bytes of outstanding data
to the corresponding address in the Congestion Avoidance phase. However,
this is described without normative language.
Moreover, Section 7.2.2 includes an algorithm how an implementation can achieve
it but this algorithm is underspecified and actually allows increasing cwnd by
more than 1*MTU per RTT.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

When cwnd is greater than ssthresh, cwnd should be incremented by
1*MTU per RTT if the sender has cwnd or more bytes of data
outstanding for the corresponding transport address.

---------
New text: (Section 7.2.2)
---------

When cwnd is greater than ssthresh, cwnd should be incremented by
1*MTU per RTT if the sender has cwnd or more bytes of data
outstanding for the corresponding transport address. The basic
guidelines for incrementing cwnd during congestion avoidance are:

o  SCTP MAY increment cwnd by 1*MTU.

o  SCTP SHOULD increment cwnd by one 1*MTU once per RTT when
   the sender has cwnd or more bytes of data outstanding for
   the corresponding transport address.

o  SCTP MUST NOT increment cwnd by more than 1*MTU per RTT.

---------
Old text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival
   that advances the Cumulative TSN Ack Point, increase
   partial_bytes_acked by the total number of bytes of all new chunks
   acknowledged in that SACK including chunks acknowledged by the new
   Cumulative TSN Ack and by Gap Ack Blocks.

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), increase cwnd by MTU, and
   reset partial_bytes_acked to (partial_bytes_acked - cwnd).

---------
New text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival,
   increase partial_bytes_acked by the total number of bytes of all
   new chunks acknowledged in that SACK including chunks acknowledged
   by the new Cumulative TSN Ack, by Gap Ack Blocks and by the number
   of bytes of duplicated chunks reported in Duplicate TSNs.

o  When partial_bytes_acked is greater than cwnd and before the
   arrival of the SACK the sender had less bytes of data outstanding
   than cwnd (i.e., before arrival of the SACK, flightsize was less
   than cwnd), reset partial_bytes_acked to cwnd.

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), partial_bytes_acked is reset
   to (partial_bytes_acked - cwnd). Next, cwnd is increased by MTU.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The basic guidelines for incrementing cwnd during congestion avoidance
phase are added into Section 7.2.2. The guidelines include the normative
language and are aligned with <xref target="RFC5681"/>.</t>
<t>The algorithm from Section 7.2.2 is improved to not allow increasing cwnd by
more than 1*MTU per RTT.</t>
</section>
</section>

<section title='Refresh of cwnd and ssthresh after Idle Period'>
<section title='Description of the Problem'>
<t><xref target='RFC4960'/> prescribes to adjust cwnd per RTO if the endpoint
does not transmit data on a given transport address. In addition to that, it
prescribes to set cwnd to the initial value after a sufficiently long idle
period. The latter is excessive. Moreover, it is unclear what is a sufficiently
long idle period.</t>
<t><xref target='RFC4960'/> doesn't specify the handling of ssthresh in the idle
case.
If ssthres is reduced due to a packet loss, ssthresh is never recovered.
So traffic can end up in Congestion Avoidance all the time, resulting in a low
sending rate and bad performance.
The problem is even more serious for SCTP because in a multi-homed
SCTP association traffic switch back to the previously failed primary path will
also lead to the situation where traffic ends up in Congestion Avoidance.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial cwnd before DATA transmission or after a sufficiently
   long idle period MUST be set to min(4*MTU, max (2*MTU, 4380
   bytes)).

---------
New text: (Section 7.2.1)
---------

o  The initial cwnd before DATA transmission MUST be set to
   min(4*MTU, max (2*MTU, 4380 bytes)).

---------
Old text: (Section 7.2.1)
---------

o  When the endpoint does not transmit data on a given transport
   address, the cwnd of the transport address should be adjusted to
   max(cwnd/2, 4*MTU) per RTO.

---------
New text: (Section 7.2.1)
---------
o  When the endpoint does not transmit data on a given transport
   address, the cwnd of the transport address should be adjusted to
   max(cwnd/2, 4*MTU) per RTO. At the first cwnd adjustment, the
   ssthresh of the transport address should be adjusted to the cwnd.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>A rule about cwnd adjustment after a sufficiently long idle period
is removed.</t>
<t>The text is updated to refresh ssthresh after the idle period. When
the idle period is detected, the cwnd value is stored to the ssthresh value.</t>
</section>
</section>

<section title='Window Updates After Receiver Window Opens Up'>
<section title='Description of the Problem'>
<t>The sending of SACK chunks for window updates is only indirectly referenced
in <xref target="RFC4960"/>, Section 6.2, where it is stated that an SCTP
receiver must not generate more than one SACK for every incoming packet, other
than to update the offered window.</t>
<t>However, the sending of window updates when the receiver window opens up
is necessary to avoid performance problems.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.2)
---------

An SCTP receiver MUST NOT generate more than one SACK for every
incoming packet, other than to update the offered window as the
receiving application consumes new data.

---------
New text: (Section 6.2)
---------

An SCTP receiver MUST NOT generate more than one SACK for every
incoming packet, other than to update the offered window as the
receiving application consumes new data. When the window opens
up, an SCTP receiver SHOULD send additional SACK chunks to update
the window even if no new data is received. The receiver MUST avoid
sending large burst of window updates.


</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text makes clear that additional SACK chunks for window updates
should be sent as long as excessive bursts are avoided.</t>
</section>
</section>

<section title='Path of DATA and Reply Chunks'>
<section title='Description of the Problem'>
<t>Section 6.4 of <xref target="RFC4960"/> describes the transmission policy
for multi-homed SCTP endpoints. However, there are the following issues with
it:
<list style='symbols'>
<t>It states that a SACK should be sent to the source address of an incoming
DATA. However, it is known that other SACK policies (e.g. sending SACKs
always to the primary path) may be more beneficial in some situations.</t>
<t>Initially it states that an endpoint should always transmit DATA chunks
to the primary path. Then it states that the rule for transmittal of reply
chunks should also be followed if the endpoint is bundling DATA chunks
together with the reply chunk which contradicts with the first statement
to always transmit DATA chunks to the primary path. Some implementations
were having problems with it and sent DATA chunks bundled with reply chunks
to a different destination address than the primary path that caused many
gaps.</t>
</list></t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.4)
---------

An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,
etc.) to the same destination transport address from which it
received the DATA or control chunk to which it is replying.  This
rule should also be followed if the endpoint is bundling DATA chunks
together with the reply chunk.

However, when acknowledging multiple DATA chunks received in packets
from different source addresses in a single SACK, the SACK chunk may
be transmitted to one of the destination transport addresses from
which the DATA or control chunks being acknowledged were received.

---------
New text: (Section 6.4)
---------

An endpoint SHOULD transmit reply chunks (e.g., INIT ACK, COOKIE ACK,
HEARTBEAT ACK, etc.) in response to control chunks to the same
destination transport address from which it received the control
chunk to which it is replying.

The selection of the destination transport address for packets containing
SACK chunks is implementation dependent. However, an endpoint SHOULD NOT vary
the destination transport address of a SACK when it receives DATA chunks
from the same source address.

When acknowledging multiple DATA chunks received in packets
from different source addresses in a single SACK, the SACK chunk MAY
be transmitted to one of the destination transport addresses from
which the DATA or control chunks being acknowledged were received.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The SACK transmission policy is left implementation dependent but it is
specified to not vary the destination address of a packet containing a SACK
chunk unless there are reasons for it as it may negatively impact RTT
measurement.</t>
<t>A confusing statement that prescribes to follow the rule for
transmittal of reply chunks when the endpoint is bundling DATA chunks
together with the reply chunk is removed.</t>
</section>
</section>


<section title='Outstanding Data, Flightsize and Data In Flight Key Terms'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> uses outstanding data, flightsize and data in
flight key terms in formulas and statements but their definitions are not
provided in Section 1.3.
Furthermore, outstanding data does not include DATA chunks which are
classified as lost but which has not been retransmitted yet and there is
a paragraph in Section 6.1 of <xref target="RFC4960"/> where this
statement is broken.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 1.3)
---------

o  Congestion window (cwnd): An SCTP variable that limits the data,
   in number of bytes, a sender can send to a particular destination
   transport address before receiving an acknowledgement.

...

o  Outstanding TSN (at an SCTP endpoint): A TSN (and the associated
   DATA chunk) that has been sent by the endpoint but for which it
   has not yet received an acknowledgement.

---------
New text: (Section 1.3)
---------

o  Outstanding TSN (at an SCTP endpoint): A TSN (and the associated
   DATA chunk) that has been sent by the endpoint but for which it
   has not yet received an acknowledgement.

o  Outstanding data (or Data outstanding or Data in flight): The
   total amount of the DATA chunks associated with outstanding TSNs.
   A retransmitted DATA chunk is counted once in outstanding data.
   A DATA chunk which is classified as lost but which has not been
   retransmitted yet is not in outstanding data.

o  Flightsize: The amount of bytes of outstanding data to a
   particular destination transport address at any given time.

o  Congestion window (cwnd): An SCTP variable that limits outstanding
   data, in number of bytes, a sender can send to a particular
   destination transport address before receiving an acknowledgement.

---------
Old text: (Section 6.1)
---------

C) When the time comes for the sender to transmit, before sending new
   DATA chunks, the sender MUST first transmit any outstanding DATA
   chunks that are marked for retransmission (limited by the current
   cwnd).

---------
New text: (Section 6.1)
---------

C) When the time comes for the sender to transmit, before sending new
   DATA chunks, the sender MUST first transmit any DATA chunks that
   are marked for retransmission (limited by the current cwnd).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Now Section 1.3, Key Terms, includes explanations of outstanding data,
data in flight and flightsize key terms.
Section 6.1 is corrected to properly use the outstanding data term.</t>
</section>
</section>

<section title='CWND Degradation due to Max.Burst'>
<section title='Description of the Problem'>
<t>Some implementations were experiencing a degradation of cwnd because of
the Max.Burst limit. This was due to misinterpretation of the suggestion
in <xref target="RFC4960"/>, Section 6.1, on how to use the Max.Burst
parameter when calculating the number of packets to transmit.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1)
---------

D) When the time comes for the sender to transmit new DATA chunks,
   the protocol parameter Max.Burst SHOULD be used to limit the
   number of packets sent.  The limit MAY be applied by adjusting
   cwnd as follows:

   if((flightsize + Max.Burst*MTU) &lt; cwnd) cwnd = flightsize +
   Max.Burst*MTU

   Or it MAY be applied by strictly limiting the number of packets
   emitted by the output routine.

---------
New text: (Section 6.1)
---------

D) When the time comes for the sender to transmit new DATA chunks,
   the protocol parameter Max.Burst SHOULD be used to limit the
   number of packets sent.  The limit MAY be applied by adjusting
   cwnd as follows:

   if((flightsize + Max.Burst*MTU) &lt; cwnd)
       cwnd = flightsize + Max.Burst*MTU

   Or it MAY be applied by strictly limiting the number of packets
   emitted by the output routine. When calculating the number of
   packets to transmit and particularly using the formula above,
   cwnd SHOULD NOT be changed.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies that cwnd should not be changed when appling
the Max.Burst limit. This mitigates packet bursts related to the reception of
SACK chunks, but not bursts related to an application sending a burst
of user messages.</t>
</section>
</section>

<section title='Reduction of RTO.Initial'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> uses 3 seconds as the default value for RTO.Initial
in accordance with Section 4.3.2.1 of <xref target="RFC1122"/>.
<xref target="RFC6298"/> updates <xref target="RFC1122"/> and lowers the initial
value of the retransmission timer from 3 seconds to 1 second.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 3 seconds
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1
   SACK.Delay - 200 milliseconds

---------
New text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 1 second
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1
   SACK.Delay - 200 milliseconds
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The value RTO.Initial has been lowered to 1 second to be in tune with
<xref target="RFC6298"/>.</t>
</section>
</section>

<section title='Ordering of Bundled SACK and ERROR Chunks'>
<section title='Description of the Problem'>
<t>When an SCTP endpoint receives a DATA chunk with an invalid stream identifier
it shall acknowledge it by sending a SACK chunk and indicate that the stream
identifier was invalid by sending an ERROR chunk. These two chunks may be bundled.
However, <xref target="RFC4960"/> requires in case of bundling that the ERROR
chunk follows the SACK chunk. This restriction of the ordering is not necessary
and might only limit interoperability.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.5)
---------

Every DATA chunk MUST carry a valid stream identifier.  If an
endpoint receives a DATA chunk with an invalid stream identifier, it
shall acknowledge the reception of the DATA chunk following the
normal procedure, immediately send an ERROR chunk with cause set to
"Invalid Stream Identifier" (see Section 3.3.10), and discard the
DATA chunk.  The endpoint may bundle the ERROR chunk in the same
packet as the SACK as long as the ERROR follows the SACK.

---------
New text: (Section 6.5)
---------

Every DATA chunk MUST carry a valid stream identifier.  If an
endpoint receives a DATA chunk with an invalid stream identifier, it
shall acknowledge the reception of the DATA chunk following the
normal procedure, immediately send an ERROR chunk with cause set to
"Invalid Stream Identifier" (see Section 3.3.10), and discard the
DATA chunk.  The endpoint may bundle the ERROR chunk and the SACK Chunk
in the same packet.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The unnecessary restriction regarding the ordering of the SACK and ERROR
chunk has been removed.</t>
</section>
</section>

<section title='Undefined Parameter Returned by RECEIVE Primitive'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> provides a description of an abstract API. In the
definition of the RECEIVE primitive an optional parameter with name
"delivery number" is mentioned. However, no definition of this parameter
is given in <xref target="RFC4960"/> and the parameter is unnecessary.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------

G) Receive

Format: RECEIVE(association id, buffer address, buffer size
        [,stream id])
-> byte count [,transport address] [,stream id] [,stream sequence
   number] [,partial flag] [,delivery number] [,payload protocol-id]

---------
New text: (Section 10.1)
---------

G) Receive

Format: RECEIVE(association id, buffer address, buffer size
        [,stream id])
-> byte count [,transport address] [,stream id] [,stream sequence
   number] [,partial flag] [,payload protocol-id]

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The undefined parameter has been removed.</t>
</section>
</section>

<section title='DSCP Changes'>
<section title='Description of the Problem'>
<t>The upper layer can change the Differentiated Services Code Point (DSCP) used
for packets being sent.
A change of the DSCP can result in packets hitting different queues on the path
and therefore the congestion control should be initialized when the DSCP is
changed by the upper layer.
This is not described in <xref target="RFC4960"/>.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
New text: (Section 7.2.5)
---------

SCTP implementations MAY allow an application to configure the
Differentiated Services Code Point (DSCP) used for sending packets.
If a DSCP change might result in outgoing packets being queued in different
queues, the congestion control parameters for all affected destination
addresses MUST be reset to their initial values.

---------
Old text: (Section 10.1)
---------

M) Set Protocol Parameters

   Format: SETPROTOCOLPARAMETERS(association id,
           [,destination transport address,]
           protocol parameter list)
   -> result

This primitive allows the local SCTP to customize the protocol
parameters.

Mandatory attributes:

o  association id - local handle to the SCTP association.

o  protocol parameter list - the specific names and values of the
   protocol parameters (e.g., Association.Max.Retrans; see Section
   15) that the SCTP user wishes to customize.

---------
Old text: (Section 10.1)
---------

M) Set Protocol Parameters

   Format: SETPROTOCOLPARAMETERS(association id,
           [,destination transport address,]
           protocol parameter list)
   -> result

This primitive allows the local SCTP to customize the protocol
parameters.

Mandatory attributes:

o  association id - local handle to the SCTP association.

o  protocol parameter list - the specific names and values of the
   protocol parameters (e.g., Association.Max.Retrans; see Section
   15, or other parameters like the DSCP) that the SCTP user wishes
   to customize.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Text describing the required action on DSCP changes has been added.</t>
</section>
</section>

<section title='Inconsistent Handling of ICMPv4 and ICMPv6 Messages'>
<section title='Description of the Problem'>
<t>Appendix C of <xref target="RFC4960"/> describes the handling of ICMPv4 and
ICMPv6 messages. The text explicitly describes the handling of ICMPv6 packets
indicating reachability problems, but does not do the same for the
corresponding ICMPv4 packets.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

ICMP1) An implementation MAY ignore all ICMPv4 messages where the
       type field is not set to "Destination Unreachable".

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem",, or "Packet Too Big".

ICMP3) An implementation MAY ignore any ICMPv4 messages where the
       code does not indicate "Protocol Unreachable" or
       "Fragmentation Needed".

ICMP4) An implementation MAY ignore all ICMPv6 messages of type
       "Parameter Problem" if the code is not "Unrecognized Next
       Header Type Encountered".

ICMP5) An implementation MUST use the payload of the ICMP message (v4
       or v6) to locate the association that sent the message to
       which ICMP is responding.  If the association cannot be found,
       an implementation SHOULD ignore the ICMP message.

ICMP6) An implementation MUST validate that the Verification Tag
       contained in the ICMP message matches the Verification Tag of
       the peer.  If the Verification Tag is not 0 and does NOT
       match, discard the ICMP message.  If it is 0 and the ICMP
       message contains enough bytes to verify that the chunk type is
       an INIT chunk and that the Initiate Tag matches the tag of the
       peer, continue with ICMP7.  If the ICMP message is too short
       or the chunk type or the Initiate Tag does not match, silently
       discard the packet.

ICMP7) If the ICMP message is either a v6 "Packet Too Big" or a v4
       "Fragmentation Needed", an implementation MAY process this
       information as defined for PATH MTU discovery.

ICMP8) If the ICMP code is an "Unrecognized Next Header Type
       Encountered" or a "Protocol Unreachable", an implementation
       MUST treat this message as an abort with the T bit set if it
       does not contain an INIT chunk.  If it does contain an INIT
       chunk and the association is in the COOKIE-WAIT state, handle
       the ICMP message like an ABORT.

ICMP9) If the ICMPv6 code is "Destination Unreachable", the
       implementation MAY mark the destination into the unreachable
       state or alternatively increment the path error counter.

---------
New text: (Appendix C)
---------

ICMP1) An implementation MAY ignore all ICMPv4 messages where the
       type field is not set to "Destination Unreachable".

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem",, or "Packet Too Big".

ICMP3) An implementation MAY ignore all ICMPv6 messages of type
       "Parameter Problem" if the code is not "Unrecognized Next
       Header Type Encountered".

ICMP4) An implementation MUST use the payload of the ICMP message (v4
       or v6) to locate the association that sent the message to
       which ICMP is responding.  If the association cannot be found,
       an implementation SHOULD ignore the ICMP message.

ICMP5) An implementation MUST validate that the Verification Tag
       contained in the ICMP message matches the Verification Tag of
       the peer.  If the Verification Tag is not 0 and does NOT
       match, discard the ICMP message.  If it is 0 and the ICMP
       message contains enough bytes to verify that the chunk type is
       an INIT chunk and that the Initiate Tag matches the tag of the
       peer, continue with ICMP7.  If the ICMP message is too short
       or the chunk type or the Initiate Tag does not match, silently
       discard the packet.

ICMP6) If the ICMP message is either a v6 "Packet Too Big" or a v4
       "Fragmentation Needed", an implementation MAY process this
       information as defined for PATH MTU discovery.

ICMP7) If the ICMP code is an "Unrecognized Next Header Type
       Encountered" or a "Protocol Unreachable", an implementation
       MUST treat this message as an abort with the T bit set if it
       does not contain an INIT chunk.  If it does contain an INIT
       chunk and the association is in the COOKIE-WAIT state, handle
       the ICMP message like an ABORT.

ICMP8) If the ICMP code is "Destination Unreachable", the
       implementation MAY mark the destination into the unreachable
       state or alternatively increment the path error counter.

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The text has been changed to not limit the processing of ICMPv4 packets
with type "Destination Unreachable" by removing the third rule. Furthermore,
remove in the ninth rule the limitation to ICMPv6.</t>
</section>
</section>

<section title='Handling of Soft Errors'>
<section title='Description of the Problem'>
<t><xref target="RFC1122"/> defines the handling of soft errors and hard errors
for TCP. Appendix C of <xref target="RFC4960"/> only deals with hard errors.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

ICMP8) If the ICMP code is "Destination Unreachable", the
       implementation MAY mark the destination into the unreachable
       state or alternatively increment the path error counter.

---------
New text: (Appendix C)
---------

ICMP8) If the ICMP code is "Destination Unreachable", the
       implementation MAY mark the destination into the unreachable
       state or alternatively increment the path error counter.
       SCTP MAY provide information to the upper layer indicating the reception
       of ICMP messages when reporting a network status change.

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Text has been added allowing the SCTP to notify the application in case
of soft errors.</t>
</section>
</section>

<section title='Honoring CWND'>
<section title='Description of the Problem'>
<t>When using the slow start algorithm, SCTP increases the congestion window
only when it is being fully utilized. Since SCTP uses DATA chunks and does not
use the congestion window to fragment user messages, this requires that some
overbooking of the congestion window is allowed.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1)
---------

B) At any given time, the sender MUST NOT transmit new data to a
   given transport address if it has cwnd or more bytes of data
   outstanding to that transport address.

---------
New text: (Section 6.1)
---------

B) At any given time, the sender MUST NOT transmit new data to a
   given transport address if it has cwnd + (PMTU - 1) or more bytes of data
   outstanding to that transport address.  If data is available the
   sender SHOULD exceed cwnd by up to (PMTU-1) bytes on a new data
   transmission if the flightsize does not currently reach cwnd.
   The breach of cwnd MUST constitute one packet only.

---------
Old text: (Section 7.2.1)
---------

o  Whenever cwnd is greater than zero, the endpoint is allowed to
   have cwnd bytes of data outstanding on that transport address.

---------
New text: (Section 7.2.1)
---------
o  Whenever cwnd is greater than zero, the endpoint is allowed to
   have cwnd bytes of data outstanding on that transport address.
   A limited overbooking as described in B) of Section 6.1 should
   be supported.

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Text was added that to clarify how the CWND limit should be handled.</t>
</section>
</section>

<section title='Zero Window Probing'>
<section title='Description of the Problem'>
<t>The text describing zero window probing was not clearly handling the
case where the window was not zero, but too small for the next DATA chunk
to be transmitted. Even in this case, zero window probing has to be performed
to avoid deadlocks.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1)
---------

A) At any given time, the data sender MUST NOT transmit new data to
   any destination transport address if its peer's rwnd indicates
   that the peer has no buffer space (i.e., rwnd is 0; see Section
   6.2.1).  However, regardless of the value of rwnd (including if it
   is 0), the data sender can always have one DATA chunk in flight to
   the receiver if allowed by cwnd (see rule B, below).  This rule
   allows the sender to probe for a change in rwnd that the sender
   missed due to the SACK's having been lost in transit from the data
   receiver to the data sender.

   When the receiver's advertised window is zero, this probe is
   called a zero window probe.  Note that a zero window probe SHOULD
   only be sent when all outstanding DATA chunks have been
   cumulatively acknowledged and no DATA chunks are in flight.  Zero
   window probing MUST be supported.

---------
New text: (Section 6.1)
---------

A) At any given time, the data sender MUST NOT transmit new data to
   any destination transport address if its peer's rwnd indicates
   that the peer has no buffer space (i.e., rwnd is smaller than the
   size of the next DATA chunk; see Section 6.2.1).
   However, regardless of the value of rwnd (including if it is 0),
   the data sender can always have one DATA chunk in flight to
   the receiver if allowed by cwnd (see rule B, below).  This rule
   allows the sender to probe for a change in rwnd that the sender
   missed due to the SACK's having been lost in transit from the data
   receiver to the data sender.

   When the receiver has no buffer space, this probe is
   called a zero window probe.  Note that a zero window probe SHOULD
   only be sent when all outstanding DATA chunks have been
   cumulatively acknowledged and no DATA chunks are in flight.  Zero
   window probing MUST be supported.

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The terminology is used in a cleaner way.</t>
</section>
</section>

</section>

<section title='IANA Considerations'>
<t>This document does not require any actions from IANA.</t>
</section>

<section title='Security Considerations'>
<t>This document does not add any security considerations to those given
in <xref target="RFC4960"/>.</t>
</section>

<section title="Acknowledgments">
<t>The authors wish to thank
Pontus Andersson,
Eric W. Biederman,
Cedric Bonnet,
Lionel Morand,
Jeff Morriss,
Karen E. E. Nielsen,
Tom Petch,
Julien Pourtet,
and
Michael Welzl
for their invaluable comments.</t>
</section>

</middle>

<back>
<references title='Normative References'>
<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.4960" ?>
</references>
<references title='Informative References'>
<?rfc include="reference.RFC.1122" ?>
<?rfc include="reference.RFC.2960" ?>
<?rfc include="reference.RFC.4460" ?>
<?rfc include="reference.RFC.5681" ?>
<?rfc include="reference.RFC.6298" ?>
</references>
</back>
</rfc>
