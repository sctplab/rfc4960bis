<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="2" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<?rfc strict="yes" ?>

<rfc category="std"
     ipr="trust200902"
     docName="draft-tuexen-tsvwg-rfc4960-errata-01.txt">
<front>

<!--
ToDo
  * Limit SSN in flight to 2^16 - 1
  * Cleanup CRC32c code
  * Remove Hostname Parameter
  * Consider implications for the Supported Address Types Parameter
-->

<title>RFC 4960 Errata and Issues</title>

<!-- *************** RANDALL STEWART *************** -->
<author initials="R. R." surname="Stewart" fullname="Randall R. Stewart">
<organization>Netflix, Inc.</organization>
<address>
    <postal>
        <street></street>
        <city>Chapin</city>
        <region>SC</region>
        <code>29036</code>
        <country>United States</country>
    </postal>
    <email>randall@lakerest.net</email>
</address>
</author>

<!-- ************** MICHAEL TUEXEN *************** -->
<author initials="M." surname="Tuexen" fullname="Michael Tuexen">
<organization abbrev='Muenster Univ. of Appl. Sciences'>
              Muenster University of Applied Sciences</organization>
<address>
    <postal>
        <street>Stegerwaldstrasse 39</street>
        <city>48565 Steinfurt</city>
        <region/><code/>
        <country>Germany</country>
    </postal>
    <email>tuexen@fh-muenster.de</email>
</address>
</author>

<!-- ************** KAREN NIELSEN *************** -->
<author initials="K. E. E." surname="Nielsen" fullname="Karen E. E. Nielsen">
<organization>Ericsson</organization>
<address>
    <postal>
        <street>Kistavaegen 25</street>
        <city>Stockholm</city>
        <code> 164 80</code>
        <country>Sweden</country>
    </postal>
    <email>karen.nielsen@tieto.com</email>
</address>
</author>

<date  />

<abstract>
<t>This document is a compilation of issues found since the publication of
RFC4960 in September 2007 based on experience with
implementing, testing, and using SCTP along with the suggested fixes.
This document provides deltas to RFC4960 and is organized in a time based way.
The issues are listed in the order they were brought up.
Because some text is changed several times the last delta in the text is the
one which should be applied.
In addition to the delta a description of the problem and the details of the
solution are also provided.</t>
</abstract>

</front>

<middle>

<section anchor='intro' title='Introduction'>
<t>This document contains a compilation of all defects found up until
the publishing of this document for <xref target="RFC4960"/> specifying the
Stream Control Transmission Protocol (SCTP).
These defects may be of an editorial or technical nature.
This document may be thought of as a companion document to be used in
the implementation of SCTP to clarify errors in the original SCTP document.</t>
<t>This document provides a history of the changes that will be compiled
into a BIS document for <xref target="RFC4960"/>. It is structured similar
to <xref target="RFC4460"/>.</t>

<t>Each error will be detailed within this document in the form of:
<list style='symbols'>
<t>The problem description,</t>
<t>The text quoted from <xref target="RFC4960"/>,</t>
<t>The replacement text that should be placed into an upcoming BIS document,</t>
<t>A description of the solution.</t>
</list></t>
<t>Note that when reading this document one must use care to assure that a field
or item is not updated further on within the document.
Each section should be applied in sequence to the original <xref target="RFC4960"/>
since this document is a historical record of the sequential changes that have
been found necessary at various inter-op events and through discussion on the
list.</t>
</section>

<section anchor='conventions' title='Conventions'>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>
</section>

<section title='Corrections to RFC 4960'>

<!-- Skeleton for an issue.
<section title='FIXME: Descriptive name of the issue'>
<section title='Description of the Problem'>
<t>FIXME</t>
</section>
<section title='Text Changes to the Document'>
<t>FIXME</t>
</section>
<section title='Solution Description'>
<t>FIXME</t>
</section>
</section>
-->

<!--
Current Erratas listed at
http://www.rfc-editor.org/errata_search.php?rfc=4960

* http://www.rfc-editor.org/errata_search.php?eid=1440 Verified
* http://www.rfc-editor.org/errata_search.php?eid=1574 Verified
* http://www.rfc-editor.org/errata_search.php?eid=2592 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3291 Held for Document Update
* http://www.rfc-editor.org/errata_search.php?eid=3423 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3788 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3804 Reported (Duplicate of 3291)
* http://www.rfc-editor.org/errata_search.php?eid=4071 Reported (Should be accepted)
* http://www.rfc-editor.org/errata_search.php?eid=4250 Reported (Should be rejected)
-->

<section title='Path Error Counter Threshold Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1440 -->

<section title='Description of the Problem'>
<t>The handling of the 'Path.Max.Retrans' parameter is described in
Section 8.2 and Section 8.3 of <xref target="RFC4960"/> in an Inconsistent
way. Whereas Section 8.2 describes that a path is marked inactive when
the path error counter exceeds the threshold, Section 8.3 says the path
is marked inactive when the path error counter reaches the threshold.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1440.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The intended state change should happen when the threshold is exceeded.</t>
</section>
</section>

<section title='Upper Layer Protocol Shutdown Request Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1574 -->
<section title='Description of the Problem'>
<t>Section 9.2 of <xref target="RFC4960"/> describes the handling of received
SHUTDOWN chunks in the SHUTDOWN-RECEIVED state instead of the handling of
shutdown requests from its upper layer in this state.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1574.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent SHUTDOWN chunks.

---------
New text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent ULP shutdown requests.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The text never intended the SCTP endpoint to ignore SHUTDOWN chunks from its
peer.
If it did the endpoints could never gracefully terminate associations in some
cases.</t>
</section>
</section>

<section title='Registration of New Chunk Types'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=2592 -->
<section title='Description of the Problem'>
<t>Section 14.1 of <xref target="RFC4960"/> should deal with new chunk types,
however, the text refers to parameter types.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 2592.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 14.1)
---------

The assignment of new chunk parameter type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk parameter MUST contain the following information:

---------
New text: (Section 14.1)
---------

The assignment of new chunk type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk type MUST contain the following information:
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Refer to chunk types as intended.</t>
</section>
</section>

<section title='Variable Parameters for INIT Chunks'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3291 -->
<!-- http://www.rfc-editor.org/errata_search.php?eid=3804 -->
<!-- The table was correctly formatted in RFC 2960 -->
<section title='Description of the Problem'>
<t>Newlines in wrong places break the layout of the table of variable
parameters for the INIT chunk in Section 3.3.2 of <xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3291 and Errata ID 3804.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5 IPv6 Address
(Note 1)               Optional    6 Cookie Preservative
Optional    9 Reserved for ECN Capable (Note 2)   Optional
32768 (0x8000) Host Name Address (Note 3)          Optional
11 Supported Address Types (Note 4)    Optional    12

---------
New text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5
IPv6 Address (Note 1)               Optional    6
Cookie Preservative                 Optional    9
Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)
Host Name Address (Note 3)          Optional    11
Supported Address Types (Note 4)    Optional    12
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Fix the formatting of the table.</t>
</section>
</section>

<section title='CRC32c Sample Code on 64-bit Platforms'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3423 -->
<section title='Description of the Problem'>
<t>The sample code for computing the CRC32c provided in <xref target="RFC4960"/>
assumes that a variable of type unsigned long uses 32 bits. This is not true
on some 64-bit platforms (for example the ones using LP64).</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3423.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = ~0L;

---------
New text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = 0xffffffffL;
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use 0xffffffffL instead of ~0L which gives the same value on platforms using
32 bits or 64 bits for variables of type unsigned long.</t>
</section>
</section>

<section title='Endpoint Failure Detection'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3788 -->
<section title='Description of the Problem'>
<t>The handling of the association error counter defined in Section 8.1 of
<xref target="RFC4960"/> can result in an association failure even if the
path used for data transmission is available, but idle.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3788.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes retransmissions to all the
destination transport addresses of the peer if it is multi-homed),
including unacknowledged HEARTBEAT chunks.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>A more refined handling for the association error counter is defined.</t>
</section>
</section>

<section title='Data Transmission Rules'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4071 -->
<section title='Description of the Problem'>
<t>When integrating the changes to Section 6.1 A) of <xref target="RFC2960"/>
as described in Section 2.15.2 of <xref target="RFC4460"/> some text was
duplicated and became the final paragraph of Section 6.1 A) of
<xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4071.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1 A))
---------
The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].

However, regardless of the value of rwnd (including if it is 0),
the data sender can always have one DATA chunk in flight to the
receiver if allowed by cwnd (see rule B below).  This rule allows
the sender to probe for a change in rwnd that the sender missed
due to the SACK having been lost in transit from the data receiver
to the data sender.

---------
New text: (Section 6.1 A))
---------

The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Last paragraph of Section 6.1 A) removed as intended in Section 2.15.2 of
<xref target="RFC4460"/>.</t>
</section>
</section>

<section title='T1-Cookie Timer'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4400 -->
<section title='Description of the Problem'>
<t>Figure 4 of <xref target="RFC4960"/> illustrates the SCTP association setup.
However, it incorrectly shows that the T1-init timer is used in the
COOKIE-ECHOED state whereas the T1-cookie timer should have been used
instead.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4400.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-init timer)         \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-init timer, &lt;-----/
 Enter ESTABLISHED state)

---------
New text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-cookie timer)       \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-cookie timer, &lt;---/
 Enter ESTABLISHED state)
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Change the figure such that the T1-cookie timer is used instead of the
T1-init timer.</t>
</section>
</section>

<section title='Miscellaneous Typos'>
<section title='Description of the Problem'>
<t>While processing <xref target="RFC4960"/> some typos were not catched.</t>
</section>
<section title='Text Changes to the Document'>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2*32 - 1 is TSN = 0.

---------
New text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2**32 - 1 is TSN = 0.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a

DATA chunk if a received DATA chunk has no user data.

---------
New text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a
DATA chunk if a received DATA chunk has no user data.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z {App
sends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------
-----> (ack delayed) (Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Start=2,End=2]
                        &lt;-----/ (remove 6 from out-queue,
 and mark 7 as "1" missing report)

---------
New text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z
{App sends 3 messages; strm 0}
DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)
(Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Strt=2,End=2]
                        &lt;-----/
(remove 6 from out-queue,
 and mark 7 as "1" missing report)
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.10)
---------
An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,

including the SCTP packet and IP headers, MUST be less that or equal
to the current Path MTU.

---------
New text: (Section 6.10)
---------

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,
including the SCTP packet and IP headers, MUST be less that or equal
to the current Path MTU.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------
o  Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

---------
New text: (Section 10.1)
---------

O  Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])
</artwork>
</figure>
<!-- The following was correct in RFC 4460 -->
<figure>
<artwork>
---------
Old text: (Appendix C)
---------
ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem",, or "Packet Too Big".

---------
New text: (Appendix C)
---------

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem", or "Packet Too Big".
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Typos fixed.</t>
</section>
</section>

<section title='CRC32c Sample Code'>
<section title='Description of the Problem'>
<t>The CRC32c computation is described in Appendix B of <xref target="RFC4960"/>.
However, the corresponding sample code and its explanation appears at the end
of Appendix C, which deals with ICMP handling.</t>
</section>
<section title='Text Changes to the Document'>
<t>Move the sample code related to CRC32c computation and its explanation
from the end of Appendix C to the end of Appendix B.</t>
</section>
<section title='Solution Description'>
<t>Text moved to the appropriate location.</t>
</section>
</section>

<section title='partial_bytes_acked after T3-rtx Expiration'>
<!-- The following was correct in RFC 4460 -->
<section title='Description of the Problem'>
<t>Section 7.2.3 of <xref target="RFC4960"/> explicitly states that
partial_bytes_acked should be reset to 0 after packet loss detecting from SACK
but the same is missed for T3-rtx timer expiration.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU

---------
New text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU
partial_bytes_acked = 0
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Specify that partial_bytes_acked should be reset to 0 after T3-rtx timer
expiration.</t>
</section>
</section>

<section title='Order of Adjustments of partial_bytes_acked and cwnd'>
<!-- The correction is in accordance with RFC 3465, Section 2.1 -->
<section title='Description of the Problem'>
<t>Section 7.2.2 of <xref target="RFC4960"/> is unclear about the order
of adjustments applied to partial_bytes_acked and cwnd in the congestion
avoidance phase.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), increase cwnd by MTU, and
   reset partial_bytes_acked to (partial_bytes_acked - cwnd).

---------
New text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), partial_bytes_acked is reset
   to (partial_bytes_acked - cwnd). Next, cwnd is increased by MTU.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text defines the exact order of adjustments of
partial_bytes_acked and cwnd in the congestion avoidance phase.</t>
</section>
</section>

<section title='HEARTBEAT ACK and the association error counter'>
<section title='Description of the Problem'>
<t>Section 8.1 and Section 8.3 of <xref target="RFC4960"/>
prescribe that the receiver of a HEARTBEAT ACK must reset the
association overall error counter. In some circumstances, e.g.
when a router discards DATA chunks but not HEARTBEAT chunks due to
the larger size of the DATA chunk, it might be better to not clear
the association error counter on reception of the HEARTBEAT ACK and
reset it only on reception of the SACK to avoid stalling the
association.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK) or a HEARTBEAT
ACK is received from the peer endpoint.

---------
New text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK). When a
HEARTBEAT ACK is received from the peer endpoint, the counter should
also be reset. The receiver of the HEARTBEAT ACK may choose not to
clear the counter if there is outstanding data on the association.
This allows for handling the possible difference in reachability
based on DATA chunks and HEARTBEAT chunks.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text provides a possibility to not reset the association
overall error counter when a HEARTBEAT ACK is received if there are
valid reasons for it.</t>
</section>
</section>

<section title='Path for Fast Retransmission'>
<!-- The following was mentioned in RFC 4460, Section 2.39 -->
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> clearly describes where to retransmit
data that is timed out when the peer is multi-homed but the same
is not stated for fast retransmissions.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.4)
---------

Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

---------
New text: (Section 6.4)
---------


Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

When its peer is multi-homed, an endpoint SHOULD send fast
retransmissions to the same destination transport address where
original data was sent to. If the primary path has been changed and
original data was sent there before the fast retransmit, the
implementation MAY send it to the new primary path.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies where to send fast retransmissions.</t>
</section>
</section>

<section title='Transmittal in Fast Recovery'>
<section title='Description of the Problem'>
<t>The Fast Retransmit on Gap Reports algorithm intends that only the
very first packet may be sent regardless of cwnd in the Fast Recovery
phase but rule 3) of <xref target="RFC4960"/>, Section 7.2.4, misses
this clarification.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.4)
---------

3)  Determine how many of the earliest (i.e., lowest TSN) DATA chunks
    marked for retransmission will fit into a single packet, subject
    to constraint of the path MTU of the destination transport
    address to which the packet is being sent.  Call this value K.
    Retransmit those K DATA chunks in a single packet.  When a Fast
    Retransmit is being performed, the sender SHOULD ignore the value
    of cwnd and SHOULD NOT delay retransmission for this single
    packet.

---------
New text: (Section 7.2.4)
---------

3)  If not in Fast Recovery, determine how many of the earliest
    (i.e., lowest TSN) DATA chunks marked for retransmission will fit
    into a single packet, subject to constraint of the path MTU of
    the destination transport address to which the packet is being
    sent. Call this value K. Retransmit those K DATA chunks in a
    single packet. When a Fast Retransmit is being performed, the
    sender SHOULD ignore the value of cwnd and SHOULD NOT delay
    retransmission for this single packet.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text explicitly specifies to send only the first packet in
the Fast Recovery phase disregarding cwnd limitations.
</t>
</section>
</section>

<section title='Initial Value of ssthresh'>
<section title='Description of the Problem'>
<t>The initial value of ssthresh should be set arbitrarily high. Using
the advertised receiver window of the peer is inappropriate if the peer
increases its window after the handshake.
Furthermore, use a higher requirements level, since not following the advice
may result in performance problems.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial value of ssthresh MAY be arbitrarily high (for
   example, implementations MAY use the size of the receiver
   advertised window).

---------
New text: (Section 7.2.1)
---------

o  The initial value of ssthresh SHOULD be arbitrarily high (e.g.,
   to the size of the largest possible advertised window).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use the same value as suggested in  <xref target="RFC5681"/>, Section 3.1,
as an appropriate initial value.
Furthermore use the same requirements level.</t>
</section>
</section>

<section title='Inconsistency in Notifications to the ULP'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> uses different normative and
non-normative keywords when describing rules for sending
notifications to the ULP. E.g. Section 8.2 says that when
a destination address becomes inactive due to an unacknowledged
DATA or HEARTBEAT, SCTP SHOULD send a notification to the upper
layer while Section 8.3 says that when a destination address
becomes inactive due to an unacknowledged HEARTBEAT, SCTP may
send a notification to the upper layer. This makes the text
inconsistent.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes retransmissions to all the
destination transport addresses of the peer if it is multi-homed),
including unacknowledged HEARTBEAT chunks.  If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint MAY report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle). If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint SHOULD report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.

---------
Old text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent).  When the peer
endpoint is multi-homed and the last chunk sent to it was a
retransmission to an alternate address, there exists an ambiguity as
to whether or not the acknowledgement should be credited to the
address of the last chunk sent.  However, this ambiguity does not
seem to bear any significant consequence to SCTP behavior.  If this
ambiguity is undesirable, the transmitter may choose not to clear the
error counter if the last chunk sent was a retransmission.

---------
New text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent), and SHOULD
also report to the upper layer when an inactive destination address
is marked as active. When the peer endpoint is multi-homed and the
last chunk sent to it was a retransmission to an alternate address,
there exists an ambiguity as to whether or not the acknowledgement
should be credited to the address of the last chunk sent. However,
this ambiguity does not seem to bear any significant consequence to
SCTP behavior. If this ambiguity is undesirable, the transmitter may
choose not to clear the error counter if the last chunk sent was a
retransmission.

---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and SHOULD
also report to the upper layer the change of reachability of this
destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint SHOULD
report to the upper layer when an inactive destination address
is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).

---------
Old text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and MUST report the peer endpoint unreachable to the upper layer (and
thus the association enters the CLOSED state).

---------
New text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and SHOULD report the peer endpoint unreachable to the upper layer
(and thus the association enters the CLOSED state).

---------
Old text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'.  If this threshold is exceeded, the
endpoint should destroy the TCB and may report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).

---------
New text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'. If this threshold is exceeded, the
endpoint should destroy the TCB and SHOULD report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The inconsistency is removed. 
Note that the new text also includes updates from earlier described issues.</t>
</section>
</section>

</section>

<section title='IANA Considerations'>
<t>This documents does not require any actions from IANA.</t>
</section>

<section title='Security Considerations'>
<t>This document does not add any security considerations to those given
in <xref target="RFC4960"/>.</t>
</section>

<section title="Acknowledgments">
<t>The authors wish to thank
Pontus Andersson,
Eric W. Biederman,
Jeff Morriss,
Tom Petch,
Julien Pourtet,
and
Maxim Proshin
for their invaluable comments.</t>
</section>

</middle>

<back>
<references title='Normative References'>
<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.4960" ?>
</references>
<references title='Informative References'>
<?rfc include="reference.RFC.2960" ?>
<?rfc include="reference.RFC.4460" ?>
<?rfc include="reference.RFC.5681" ?>
</references>
</back>
</rfc>
