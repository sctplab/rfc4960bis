<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="2" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<?rfc strict="yes" ?>

<rfc category="info"
     ipr="trust200902"
     docName="draft-tuexen-tsvwg-rfc4960-errata-03.txt">
<front>

<!--
ToDo
  * Limit SSN in flight to 2^16 - 1
  * Cleanup CRC32c code
  * Remove Hostname Parameter
  * Consider implications for the Supported Address Types Parameter
-->

<title>RFC 4960 Errata and Issues</title>

<!-- *************** RANDALL STEWART *************** -->
<author initials="R. R." surname="Stewart" fullname="Randall R. Stewart">
<organization>Netflix, Inc.</organization>
<address>
    <postal>
        <street></street>
        <city>Chapin</city>
        <region>SC</region>
        <code>29036</code>
        <country>United States</country>
    </postal>
    <email>randall@lakerest.net</email>
</address>
</author>

<!-- ************** MICHAEL TUEXEN *************** -->
<author initials="M." surname="Tuexen" fullname="Michael Tuexen">
<organization abbrev='Muenster Univ. of Appl. Sciences'>
              Muenster University of Applied Sciences</organization>
<address>
    <postal>
        <street>Stegerwaldstrasse 39</street>
        <city>48565 Steinfurt</city>
        <region/><code/>
        <country>Germany</country>
    </postal>
    <email>tuexen@fh-muenster.de</email>
</address>
</author>

<!-- ************** MAKSIM PROSHIN *************** -->
<author initials="M." surname="Proshin" fullname="Maksim Proshin">
<organization>Ericsson</organization>
<address>
    <postal>
        <street>Kistavaegen 25</street>
        <city>Stockholm</city>
        <code> 164 80</code>
        <country>Sweden</country>
    </postal>
    <email>mproshin@tieto.mera.ru</email>
</address>
</author>

<date  />

<abstract>
<t>This document is a compilation of issues found since the publication of
RFC4960 in September 2007 based on experience with
implementing, testing, and using SCTP along with the suggested fixes.
This document provides deltas to RFC4960 and is organized in a time based way.
The issues are listed in the order they were brought up.
Because some text is changed several times the last delta in the text is the
one which should be applied.
In addition to the delta a description of the problem and the details of the
solution are also provided.</t>
</abstract>

</front>

<middle>

<section anchor='intro' title='Introduction'>
<t>This document contains a compilation of all defects found up until
the publishing of this document for <xref target="RFC4960"/> specifying the
Stream Control Transmission Protocol (SCTP).
These defects may be of an editorial or technical nature.
This document may be thought of as a companion document to be used in
the implementation of SCTP to clarify errors in the original SCTP document.</t>
<t>This document provides a history of the changes that will be compiled
into a BIS document for <xref target="RFC4960"/>. It is structured similar
to <xref target="RFC4460"/>.</t>

<t>Each error will be detailed within this document in the form of:
<list style='symbols'>
<t>The problem description,</t>
<t>The text quoted from <xref target="RFC4960"/>,</t>
<t>The replacement text that should be placed into an upcoming BIS document,</t>
<t>A description of the solution.</t>
</list></t>
<t>Note that when reading this document one must use care to assure that a field
or item is not updated further on within the document.
Each section should be applied in sequence to the original <xref target="RFC4960"/>
since this document is a historical record of the sequential changes that have
been found necessary at various inter-op events and through discussion on the
list.</t>
</section>

<section anchor='conventions' title='Conventions'>
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>
</section>

<section title='Corrections to RFC 4960'>

<!-- Skeleton for an issue.
<section title='FIXME: Descriptive name of the issue'>
<section title='Description of the Problem'>
<t>FIXME</t>
</section>
<section title='Text Changes to the Document'>
<t>FIXME</t>
</section>
<section title='Solution Description'>
<t>FIXME</t>
</section>
</section>
-->

<!--
Current Erratas listed at
http://www.rfc-editor.org/errata_search.php?rfc=4960

* http://www.rfc-editor.org/errata_search.php?eid=1440 Verified
* http://www.rfc-editor.org/errata_search.php?eid=1574 Verified
* http://www.rfc-editor.org/errata_search.php?eid=2592 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3291 Held for Document Update
* http://www.rfc-editor.org/errata_search.php?eid=3423 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3788 Verified
* http://www.rfc-editor.org/errata_search.php?eid=3804 Reported (Duplicate of 3291)
* http://www.rfc-editor.org/errata_search.php?eid=4071 Reported (Should be accepted)
* http://www.rfc-editor.org/errata_search.php?eid=4250 Reported (Should be rejected)
-->

<section title='Path Error Counter Threshold Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1440 -->

<section title='Description of the Problem'>
<t>The handling of the 'Path.Max.Retrans' parameter is described in
Section 8.2 and Section 8.3 of <xref target="RFC4960"/> in an Inconsistent
way. Whereas Section 8.2 describes that a path is marked inactive when
the path error counter exceeds the threshold, Section 8.3 says the path
is marked inactive when the path error counter reaches the threshold.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1440.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The intended state change should happen when the threshold is exceeded.</t>
</section>
</section>

<section title='Upper Layer Protocol Shutdown Request Handling'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=1574 -->
<section title='Description of the Problem'>
<t>Section 9.2 of <xref target="RFC4960"/> describes the handling of received
SHUTDOWN chunks in the SHUTDOWN-RECEIVED state instead of the handling of
shutdown requests from its upper layer in this state.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 1574.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent SHUTDOWN chunks.

---------
New text: (Section 9.2)
---------

Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT
send a SHUTDOWN in response to a ULP request, and should discard
subsequent ULP shutdown requests.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The text never intended the SCTP endpoint to ignore SHUTDOWN chunks from its
peer.
If it did the endpoints could never gracefully terminate associations in some
cases.</t>
</section>
</section>

<section title='Registration of New Chunk Types'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=2592 -->
<section title='Description of the Problem'>
<t>Section 14.1 of <xref target="RFC4960"/> should deal with new chunk types,
however, the text refers to parameter types.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 2592.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 14.1)
---------

The assignment of new chunk parameter type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk parameter MUST contain the following information:

---------
New text: (Section 14.1)
---------

The assignment of new chunk type codes is done through an
IETF Consensus action, as defined in [RFC2434].  Documentation of the
chunk type MUST contain the following information:
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Refer to chunk types as intended.</t>
</section>
</section>

<section title='Variable Parameters for INIT Chunks'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3291 -->
<!-- http://www.rfc-editor.org/errata_search.php?eid=3804 -->
<!-- The table was correctly formatted in RFC 2960 -->
<section title='Description of the Problem'>
<t>Newlines in wrong places break the layout of the table of variable
parameters for the INIT chunk in Section 3.3.2 of <xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3291 and Errata ID 3804.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5 IPv6 Address
(Note 1)               Optional    6 Cookie Preservative
Optional    9 Reserved for ECN Capable (Note 2)   Optional
32768 (0x8000) Host Name Address (Note 3)          Optional
11 Supported Address Types (Note 4)    Optional    12

---------
New text: (Section 3.3.2)
---------

Variable Parameters                  Status     Type Value
-------------------------------------------------------------
IPv4 Address (Note 1)               Optional    5
IPv6 Address (Note 1)               Optional    6
Cookie Preservative                 Optional    9
Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)
Host Name Address (Note 3)          Optional    11
Supported Address Types (Note 4)    Optional    12
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Fix the formatting of the table.</t>
</section>
</section>

<section title='CRC32c Sample Code on 64-bit Platforms'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3423 -->
<section title='Description of the Problem'>
<t>The sample code for computing the CRC32c provided in <xref target="RFC4960"/>
assumes that a variable of type unsigned long uses 32 bits. This is not true
on some 64-bit platforms (for example the ones using LP64).</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3423.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = ~0L;

---------
New text: (Appendix C)
---------

unsigned long
generate_crc32c(unsigned char *buffer, unsigned int length)
{
  unsigned int i;
  unsigned long crc32 = 0xffffffffL;
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use 0xffffffffL instead of ~0L which gives the same value on platforms using
32 bits or 64 bits for variables of type unsigned long.</t>
</section>
</section>

<section anchor='endpoint_failure_detection'
         title='Endpoint Failure Detection'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=3788 -->
<section title='Description of the Problem'>
<t>The handling of the association error counter defined in Section 8.1 of
<xref target="RFC4960"/> can result in an association failure even if the
path used for data transmission is available, but idle.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 3788.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes retransmissions to all the
destination transport addresses of the peer if it is multi-homed),
including unacknowledged HEARTBEAT chunks.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>A more refined handling for the association error counter is defined.</t>
</section>
</section>

<section title='Data Transmission Rules'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4071 -->
<section title='Description of the Problem'>
<t>When integrating the changes to Section 6.1 A) of <xref target="RFC2960"/>
as described in Section 2.15.2 of <xref target="RFC4460"/> some text was
duplicated and became the final paragraph of Section 6.1 A) of
<xref target="RFC4960"/>.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4071.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1 A))
---------
The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].

However, regardless of the value of rwnd (including if it is 0),
the data sender can always have one DATA chunk in flight to the
receiver if allowed by cwnd (see rule B below).  This rule allows
the sender to probe for a change in rwnd that the sender missed
due to the SACK having been lost in transit from the data receiver
to the data sender.

---------
New text: (Section 6.1 A))
---------

The sender MUST also have an algorithm for sending new DATA chunks
to avoid silly window syndrome (SWS) as described in [RFC0813].
The algorithm can be similar to the one described in Section
4.2.3.4 of [RFC1122].
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Last paragraph of Section 6.1 A) removed as intended in Section 2.15.2 of
<xref target="RFC4460"/>.</t>
</section>
</section>

<section title='T1-Cookie Timer'>
<!-- http://www.rfc-editor.org/errata_search.php?eid=4400 -->
<section title='Description of the Problem'>
<t>Figure 4 of <xref target="RFC4960"/> illustrates the SCTP association setup.
However, it incorrectly shows that the T1-init timer is used in the
COOKIE-ECHOED state whereas the T1-cookie timer should have been used
instead.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4400.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-init timer)         \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-init timer, &lt;-----/
 Enter ESTABLISHED state)

---------
New text: (Section 5.1.6, Figure 4)
---------

COOKIE ECHO [Cookie_Z] ------\
(Start T1-cookie timer)       \
(Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                      state)
                               /---- COOKIE-ACK
                              /
(Cancel T1-cookie timer, &lt;---/
 Enter ESTABLISHED state)
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Change the figure such that the T1-cookie timer is used instead of the
T1-init timer.</t>
</section>
</section>

<section title='Miscellaneous Typos'>
<section title='Description of the Problem'>
<t>While processing <xref target="RFC4960"/> some typos were not catched.</t>
</section>
<section title='Text Changes to the Document'>
<!-- The following was already incorrect in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2*32 - 1 is TSN = 0.

---------
New text: (Section 1.6)
---------

Transmission Sequence Numbers wrap around when they reach 2**32 - 1.
That is, the next TSN a DATA chunk MUST use after transmitting TSN =
2**32 - 1 is TSN = 0.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a

DATA chunk if a received DATA chunk has no user data.

---------
New text: (Section 3.3.10.9)
---------

No User Data: This error cause is returned to the originator of a
DATA chunk if a received DATA chunk has no user data.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z {App
sends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------
-----> (ack delayed) (Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Start=2,End=2]
                        &lt;-----/ (remove 6 from out-queue,
 and mark 7 as "1" missing report)

---------
New text: (Section 6.7, Figure 9)
---------

Endpoint A                                    Endpoint Z
{App sends 3 messages; strm 0}
DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)
(Start T3-rtx timer)

DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                            immediately send ack)
                                /----- SACK [TSN Ack=6,Block=1,
                               /             Strt=2,End=2]
                        &lt;-----/
(remove 6 from out-queue,
 and mark 7 as "1" missing report)
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 6.10)
---------
An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,

including the SCTP packet and IP headers, MUST be less that or equal
to the current Path MTU.

---------
New text: (Section 6.10)
---------

An endpoint bundles chunks by simply including multiple chunks in one
outbound SCTP packet.  The total size of the resultant IP datagram,
including the SCTP packet and IP headers, MUST be less that or equal
to the current Path MTU.
</artwork>
</figure>
<!-- The following was correct in RFC 2960 -->
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------
o  Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

---------
New text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])
</artwork>
</figure>
<!-- The following was correct in RFC 4460 -->
<figure>
<artwork>
---------
Old text: (Appendix C)
---------
ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem",, or "Packet Too Big".

---------
New text: (Appendix C)
---------

ICMP2) An implementation MAY ignore all ICMPv6 messages where the
       type field is not "Destination Unreachable", "Parameter
       Problem", or "Packet Too Big".
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Typos fixed.</t>
</section>
</section>

<section title='CRC32c Sample Code'>
<section title='Description of the Problem'>
<t>The CRC32c computation is described in Appendix B of <xref target="RFC4960"/>.
However, the corresponding sample code and its explanation appears at the end
of Appendix C, which deals with ICMP handling.</t>
</section>
<section title='Text Changes to the Document'>
<t>Move the sample code related to CRC32c computation and its explanation
from the end of Appendix C to the end of Appendix B.</t>
</section>
<section title='Solution Description'>
<t>Text moved to the appropriate location.</t>
</section>
</section>

<section title='partial_bytes_acked after T3-rtx Expiration'>
<!-- The following was correct in RFC 4460 -->
<section title='Description of the Problem'>
<t>Section 7.2.3 of <xref target="RFC4960"/> explicitly states that
partial_bytes_acked should be reset to 0 after packet loss detecting from SACK
but the same is missed for T3-rtx timer expiration.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU

---------
New text: (Section 7.2.3)
---------

When the T3-rtx timer expires on an address, SCTP should perform slow
start by:

ssthresh = max(cwnd/2, 4*MTU)
cwnd = 1*MTU
partial_bytes_acked = 0
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Specify that partial_bytes_acked should be reset to 0 after T3-rtx timer
expiration.</t>
</section>
</section>

<section title='Order of Adjustments of partial_bytes_acked and cwnd'>
<!-- The correction is in accordance with RFC 3465, Section 2.1 -->
<section title='Description of the Problem'>
<t>Section 7.2.2 of <xref target="RFC4960"/> is unclear about the order
of adjustments applied to partial_bytes_acked and cwnd in the congestion
avoidance phase.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), increase cwnd by MTU, and
   reset partial_bytes_acked to (partial_bytes_acked - cwnd).

---------
New text: (Section 7.2.2)
---------

o  When partial_bytes_acked is equal to or greater than cwnd and
   before the arrival of the SACK the sender had cwnd or more bytes
   of data outstanding (i.e., before arrival of the SACK, flightsize
   was greater than or equal to cwnd), partial_bytes_acked is reset
   to (partial_bytes_acked - cwnd). Next, cwnd is increased by MTU.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text defines the exact order of adjustments of
partial_bytes_acked and cwnd in the congestion avoidance phase.</t>
</section>
</section>

<section title='HEARTBEAT ACK and the association error counter'>
<section title='Description of the Problem'>
<t>Section 8.1 and Section 8.3 of <xref target="RFC4960"/>
prescribe that the receiver of a HEARTBEAT ACK must reset the
association overall error counter. In some circumstances, e.g.
when a router discards DATA chunks but not HEARTBEAT chunks due to
the larger size of the DATA chunk, it might be better to not clear
the association error counter on reception of the HEARTBEAT ACK and
reset it only on reception of the SACK to avoid stalling the
association.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK) or a HEARTBEAT
ACK is received from the peer endpoint.

---------
New text: (Section 8.1)
---------

The counter shall be reset each time a DATA chunk sent to that peer
endpoint is acknowledged (by the reception of a SACK). When a
HEARTBEAT ACK is received from the peer endpoint, the counter should
also be reset. The receiver of the HEARTBEAT ACK may choose not to
clear the counter if there is outstanding data on the association.
This allows for handling the possible difference in reachability
based on DATA chunks and HEARTBEAT chunks.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text provides a possibility to not reset the association
overall error counter when a HEARTBEAT ACK is received if there are
valid reasons for it.</t>
</section>
</section>

<section title='Path for Fast Retransmission'>
<!-- The following was mentioned in RFC 4460, Section 2.39 -->
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> clearly describes where to retransmit
data that is timed out when the peer is multi-homed but the same
is not stated for fast retransmissions.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.4)
---------

Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

---------
New text: (Section 6.4)
---------


Furthermore, when its peer is multi-homed, an endpoint SHOULD try to
retransmit a chunk that timed out to an active destination transport
address that is different from the last destination address to which
the DATA chunk was sent.

When its peer is multi-homed, an endpoint SHOULD send fast
retransmissions to the same destination transport address where
original data was sent to. If the primary path has been changed and
original data was sent there before the fast retransmit, the
implementation MAY send it to the new primary path.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies where to send fast retransmissions.</t>
</section>
</section>

<section title='Transmittal in Fast Recovery'>
<section title='Description of the Problem'>
<t>The Fast Retransmit on Gap Reports algorithm intends that only the
very first packet may be sent regardless of cwnd in the Fast Recovery
phase but rule 3) of <xref target="RFC4960"/>, Section 7.2.4, misses
this clarification.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.4)
---------

3)  Determine how many of the earliest (i.e., lowest TSN) DATA chunks
    marked for retransmission will fit into a single packet, subject
    to constraint of the path MTU of the destination transport
    address to which the packet is being sent.  Call this value K.
    Retransmit those K DATA chunks in a single packet.  When a Fast
    Retransmit is being performed, the sender SHOULD ignore the value
    of cwnd and SHOULD NOT delay retransmission for this single
    packet.

---------
New text: (Section 7.2.4)
---------

3)  If not in Fast Recovery, determine how many of the earliest
    (i.e., lowest TSN) DATA chunks marked for retransmission will fit
    into a single packet, subject to constraint of the path MTU of
    the destination transport address to which the packet is being
    sent. Call this value K. Retransmit those K DATA chunks in a
    single packet. When a Fast Retransmit is being performed, the
    sender SHOULD ignore the value of cwnd and SHOULD NOT delay
    retransmission for this single packet.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text explicitly specifies to send only the first packet in
the Fast Recovery phase disregarding cwnd limitations.
</t>
</section>
</section>

<section title='Initial Value of ssthresh'>
<section title='Description of the Problem'>
<t>The initial value of ssthresh should be set arbitrarily high. Using
the advertised receiver window of the peer is inappropriate if the peer
increases its window after the handshake.
Furthermore, use a higher requirements level, since not following the advice
may result in performance problems.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial value of ssthresh MAY be arbitrarily high (for
   example, implementations MAY use the size of the receiver
   advertised window).

---------
New text: (Section 7.2.1)
---------

o  The initial value of ssthresh SHOULD be arbitrarily high (e.g.,
   to the size of the largest possible advertised window).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Use the same value as suggested in  <xref target="RFC5681"/>, Section 3.1,
as an appropriate initial value.
Furthermore use the same requirements level.</t>
</section>
</section>

<section title='Automatically Confirmed Addresses'>
<section title='Description of the Problem'>
<t>The Path Verification procedure of <xref target="RFC4960"/>
prescribes that any address passed to the sender of the INIT by its
upper layer is automatically CONFIRMED. This however is unclear if
only addresses in the request to initiate association establishment
are considered or any addresses provided by the upper layer in any
requests (e.g. in 'Set Primary').</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.4)
---------

1)  Any address passed to the sender of the INIT by its upper layer
   is automatically considered to be CONFIRMED.

---------
New text: (Section 5.4)
---------

1)  Any addresses passed to the sender of the INIT by its upper
   layer in the request to initialize an association is
   automatically considered to be CONFIRMED.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies that only addresses provided by the upper
layer in the request to initialize an association are automatically
confirmed.</t>
</section>
</section>

<section title='Only One Packet after Retransmission Timeout'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> is not completely clear when it describes data
transmission after T3-rtx timer expiration. Section 7.2.1 does not specify
how many packets are allowed to be sent after T3-rtx timer expiration if
more than one packet fit into cwnd. At the same time, Section 7.2.3 has the text
without normative language saying that SCTP should ensure that no more than one
packet will be in flight after T3-rtx timer expiration until successful
acknowledgment. It makes the text inconsistent.</t>
</section>

<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.1)
---------

o  The initial cwnd after a retransmission timeout MUST be no more
   than 1*MTU.

---------
New text: (Section 7.2.1)
---------

o  The initial cwnd after a retransmission timeout MUST be no more
   than 1*MTU and only one packet is allowed to be in flight
   until successful acknowledgement.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clearly specifies that only one packet is allowed to be
sent after T3-rtx timer expiration until successful acknowledgement.</t>
</section>
</section>

<section title='INIT ACK Path for INIT in COOKIE-WAIT State'>
<section title='Description of the Problem'>
<t>In case of an INIT received in the COOKIE-WAIT state
<xref target="RFC4960"/> prescribes to send an INIT ACK to the
same destination address to which the original INIT has been sent.
This text does not address the possibility of the upper layer to
provide multiple remote IP addresses while requesting the association
establishment. If the upper layer has provided multiple IP
addresses and only a subset of these addresses are supported by the
peer then the destination address of the original INIT may be
absent in the incoming INIT and sending INIT ACK to that address
is useless.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 5.2.1)
---------

Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST
respond with an INIT ACK using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged).  When
responding, the endpoint MUST send the INIT ACK back to the same
address that the original INIT (sent by this endpoint) was sent.

---------
New text: (Section 5.2.1)
---------

Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST
respond with an INIT ACK using the same parameters it sent in its
original INIT chunk (including its Initiate Tag, unchanged). When
responding, the following rules MUST be applied:

1)  The INIT ACK MUST only be sent to an address passed by the upper
    layer in the request to initialize the association.

2)  The INIT ACK MUST only be sent to an address reported in the
    incoming INIT.

3)  The INIT ACK SHOULD be sent to the source address of the
    received INIT.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text requires sending INIT ACK to the destination address
that is passed by the upper layer and reported in the incoming INIT.
If the source address of the INIT fulfills it then sending the
INIT ACK to the source address of the INIT is the preferred behavior.</t>
</section>
</section>

<section title='Zero Window Probing and Unreachable Primary Path'>
<section title='Description of the Problem'>
<t>Section 6.1 of <xref target="RFC4960"/> states that when sending
zero window probes, SCTP should neither increment the association
counter nor increment the destination address error counter if it continues
to receive new packets from the peer. But receiving new packets
from the peer does not guarantee peer's accessibility and, if the
destination address becomes unreachable during zero window probing,
SCTP cannot get a changed rwnd until it switches the destination
address for probes.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.1)
---------

If the sender continues to receive new packets from the receiver
while doing zero window probing, the unacknowledged window probes
should not increment the error counter for the association or any
destination transport address.  This is because the receiver MAY
keep its window closed for an indefinite time.  Refer to Section
6.2 on the receiver behavior when it advertises a zero window.

---------
New text: (Section 6.1)
---------

If the sender continues to receive SACKs from the peer
while doing zero window probing, the unacknowledged window probes
should not increment the error counter for the association or any
destination transport address.  This is because the receiver MAY
keep its window closed for an indefinite time.  Refer to Section
6.2 on the receiver behavior when it advertises a zero window.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text clarifies that if the receiver continues to send
SACKs, the sender of probes should not increment the error counter
of the association and the destination address even if the SACKs
do not acknowledge the probes.</t>
</section>
</section>

<section title='Normative Language in Section 10'>
<section title='Description of the Problem'>
<t>Section 10 of <xref target="RFC4960"/> is informative and normative language
such as MUST and MAY cannot be used there.
However, there are several places in Section 10 where MUST and MAY are used.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 10.1)
---------

E) Send

 Format: SEND(association id, buffer address, byte count [,context]
         [,stream id] [,life time] [,destination transport address]
         [,unordered flag] [,no-bundle flag] [,payload protocol-id] )
 -> result

...

o  no-bundle flag - instructs SCTP not to bundle this user data with
   other outbound DATA chunks.  SCTP MAY still bundle even when this
   flag is present, when faced with network congestion.

---------
New text: (Section 10.1)
---------

E) Send

 Format: SEND(association id, buffer address, byte count [,context]
         [,stream id] [,life time] [,destination transport address]
         [,unordered flag] [,no-bundle flag] [,payload protocol-id] )
 -> result

...

o  no-bundle flag - instructs SCTP not to bundle this user data with
   other outbound DATA chunks.  SCTP may still bundle even when this
   flag is present, when faced with network congestion.

---------
Old text: (Section 10.1)
---------

G) Receive

 Format: RECEIVE(association id, buffer address, buffer size
         [,stream id])
 -> byte count [,transport address] [,stream id] [,stream sequence
    number] [,partial flag] [,delivery number] [,payload protocol-id]

...

o  partial flag - if this returned flag is set to 1, then this
   Receive contains a partial delivery of the whole message.  When
   this flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

G) Receive

 Format: RECEIVE(association id, buffer address, buffer size
         [,stream id])
 -> byte count [,transport address] [,stream id] [,stream sequence
    number] [,partial flag] [,delivery number] [,payload protocol-id]

...

o  partial flag - if this returned flag is set to 1, then this
   Receive contains a partial delivery of the whole message.  When
   this flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
Old text: (Section 10.1)
---------

N) Receive Unsent Message

   Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer
           size [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

N) Receive Unsent Message

   Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer
           size [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
Old text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number MUST
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.

---------
New text: (Section 10.1)
---------

O) Receive Unacknowledged Message

   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer
           size, [,stream id] [, stream sequence number] [,partial
           flag] [,payload protocol-id])

...

o  partial flag - if this returned flag is set to 1, then this
   message is a partial delivery of the whole message.  When this
   flag is set, the stream id and Stream Sequence Number must
   accompany this receive.  When this flag is set to 0, it indicates
   that no more deliveries will be received for this Stream Sequence
   Number.
=======
Old text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival
   that advances the Cumulative TSN Ack Point, increase
   partial_bytes_acked by the total number of bytes of all new chunks
   acknowledged in that SACK including chunks acknowledged by the new
   Cumulative TSN Ack and by Gap Ack Blocks.

---------
New text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival,
   increase partial_bytes_acked by the total number of bytes of all
   new chunks acknowledged in that SACK including chunks acknowledged
   by the new Cumulative TSN Ack, by Gap Ack Blocks and by the number
   of bytes of duplicated chunks reported in Duplicate TSNs.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The normative language is removed from Section 10.</t>
</section>
</section>

<section title='Increase of partial_bytes_acked in Congestion Avoidance'>
<section title='Description of the Problem'>
<t>Two issues have been discovered with the partial_bytes_acked handling
described in Section 7.2.2 of <xref target="RFC4960"/>:
<list style='symbols'>
<t>If the Cumulative TSN Ack Point is not advanced but the SACK chunk
acknowledges new TSNs in the Gap Ack Blocks, these newly acknowledged TSNs
are not considered for partial_bytes_acked although these TSNs were
successfully received by the peer.</t>
<t>Duplicate TSNs are not considered in partial_bytes_acked although
they confirm that the DATA chunks were successfully received by the peer.</t>
</list></t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival
   that advances the Cumulative TSN Ack Point, increase
   partial_bytes_acked by the total number of bytes of all new chunks
   acknowledged in that SACK including chunks acknowledged by the new
   Cumulative TSN Ack and by Gap Ack Blocks.

---------
New text: (Section 7.2.2)
---------

o  Whenever cwnd is greater than ssthresh, upon each SACK arrival,
   increase partial_bytes_acked by the total number of bytes of all
   new chunks acknowledged in that SACK including chunks acknowledged
   by the new Cumulative TSN Ack, by Gap Ack Blocks and by the number
   of bytes of duplicated chunks reported in Duplicate TSNs.
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>Now partial_bytes_acked is increased by TSNs reported as duplicated
as well as TSNs newly acknowledged in Gap Ack Blocks even if the
Cumulative TSN Ack Point is not advanced.</t>
</section>
</section>

<section title='Inconsistency in Notifications Handling'>
<section title='Description of the Problem'>
<t><xref target="RFC4960"/> uses inconsistent normative and
non-normative language when describing rules for sending
notifications to the upper layer.
E.g. Section 8.2 of <xref target="RFC4960"/> says that when a destination
address becomes inactive due to an unacknowledged DATA chunk or HEARTBEAT chunk,
SCTP SHOULD send a notification to the upper layer while Section 8.3 of
<xref target="RFC4960"/> says that when a destination address becomes inactive
due to an unacknowledged HEARTBEAT chunk, SCTP may send a notification to the
upper layer.</t>
<t>This makes the text inconsistent.</t>
</section>
<section title='Text Changes to the Document'>
<t>The following cahnge is based on the change described in
<xref target='endpoint_failure_detection'/>.</t>
<figure>
<artwork>
---------
Old text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle). If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint MAY report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.

---------
New text: (Section 8.1)
---------

An endpoint shall keep a counter on the total number of consecutive
retransmissions to its peer (this includes data retransmissions
to all the destination transport addresses of the peer if it is
multi-homed), including the number of unacknowledged HEARTBEAT
chunks observed on the path which currently is used for data
transfer. Unacknowledged HEARTBEAT chunks observed on paths
different from the path currently used for data transfer shall
not increment the association error counter, as this could lead
to association closure even if the path which currently is used for
data transfer is available (but idle). If the value of this
counter exceeds the limit indicated in the protocol parameter
'Association.Max.Retrans', the endpoint shall consider the peer
endpoint unreachable and shall stop transmitting any more data to it
(and thus the association enters the CLOSED state).  In addition, the
endpoint SHOULD report the failure to the upper layer and optionally
report back all outstanding user data remaining in its outbound
queue.  The association is automatically closed when the peer
endpoint becomes unreachable.
</artwork>
</figure>
<t>The following changes are based on <xref target='RFC4960'/>.</t>
<figure>
<artwork>
---------
Old text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent).  When the peer
endpoint is multi-homed and the last chunk sent to it was a
retransmission to an alternate address, there exists an ambiguity as
to whether or not the acknowledgement should be credited to the
address of the last chunk sent.  However, this ambiguity does not
seem to bear any significant consequence to SCTP behavior.  If this
ambiguity is undesirable, the transmitter may choose not to clear the
error counter if the last chunk sent was a retransmission.

---------
New text: (Section 8.2)
---------

When an outstanding TSN is acknowledged or a HEARTBEAT sent to that
address is acknowledged with a HEARTBEAT ACK, the endpoint shall
clear the error counter of the destination transport address to which
the DATA chunk was last sent (or HEARTBEAT was sent), and SHOULD
also report to the upper layer when an inactive destination address
is marked as active. When the peer endpoint is multi-homed and the
last chunk sent to it was a retransmission to an alternate address,
there exists an ambiguity as to whether or not the acknowledgement
should be credited to the address of the last chunk sent. However,
this ambiguity does not seem to bear any significant consequence to
SCTP behavior. If this ambiguity is undesirable, the transmitter may
choose not to clear the error counter if the last chunk sent was a
retransmission.

---------
Old text: (Section 8.3)
---------

When the value of this counter reaches the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and may also
optionally report to the upper layer the change of reachability of
this destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
New text: (Section 8.3)
---------

When the value of this counter exceeds the protocol parameter
'Path.Max.Retrans', the endpoint should mark the corresponding
destination address as inactive if it is not so marked, and SHOULD
also report to the upper layer the change of reachability of this
destination address.  After this, the endpoint should continue
HEARTBEAT on this destination address but should stop increasing the
counter.

---------
Old text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked.  The endpoint may
optionally report to the upper layer when an inactive destination
address is marked as active due to the reception of the latest
HEARTBEAT ACK.  The receiver of the HEARTBEAT ACK must also clear the
association overall error count as well (as defined in Section 8.1).

---------
New text: (Section 8.3)
---------

Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT
should clear the error counter of the destination transport address
to which the HEARTBEAT was sent, and mark the destination transport
address as active if it is not so marked. The endpoint SHOULD
report to the upper layer when an inactive destination address
is marked as active due to the reception of the latest
HEARTBEAT ACK. The receiver of the HEARTBEAT ACK should also clear
the association overall error counter (as defined in Section 8.1).

---------
Old text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and MUST report the peer endpoint unreachable to the upper layer (and
thus the association enters the CLOSED state).

---------
New text: (Section 9.2)
---------

An endpoint should limit the number of retransmissions of the
SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.
If this threshold is exceeded, the endpoint should destroy the TCB
and SHOULD report the peer endpoint unreachable to the upper layer
(and thus the association enters the CLOSED state).

---------
Old text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'.  If this threshold is exceeded, the
endpoint should destroy the TCB and may report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).

---------
New text: (Section 9.2)
---------

The sender of the SHUTDOWN ACK should limit the number of
retransmissions of the SHUTDOWN ACK chunk to the protocol parameter
'Association.Max.Retrans'. If this threshold is exceeded, the
endpoint should destroy the TCB and SHOULD report the peer endpoint
unreachable to the upper layer (and thus the association enters the
CLOSED state).
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The inconsistencies are removed by using consistently SHOULD.</t>
</section>
</section>

<section title='SACK.Delay not listed as a Protocol Parameter'>
<section title='Description of the Problem'>
<t>SCTP as specified in <xref target='RFC4960'/> supports delaying SACKs.
The timer value for this is a parameter and Section 6.2 of
<xref target='RFC4960'/> specifies a default and maximum value for it.
However, defining a name for this parameter and listing it in the table
of protocol parameters in Section 15 of <xref target='RFC4960'/> is missing.</t>
<t>This issue was reported as an Errata for <xref target="RFC4960"/> with
Errata ID 4656.</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.2)
---------

An implementation MUST NOT allow the maximum delay to be configured
to be more than 500 ms.  In other words, an implementation MAY lower
this value below 500 ms but MUST NOT raise it above 500 ms.

---------
New text: (Section 6.2)
---------

An implementation MUST NOT allow the maximum delay (protocol
parameter 'SACK.Delay') to be configured to be more than 500 ms.
In other words, an implementation MAY lower the value of
SACK.Delay below 500 ms but MUST NOT raise it above 500 ms.

---------
Old text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 3 seconds
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1

---------
New text: (Section 15)
---------

The following protocol parameters are RECOMMENDED:

   RTO.Initial - 3 seconds
   RTO.Min - 1 second
   RTO.Max - 60 seconds
   Max.Burst - 4
   RTO.Alpha - 1/8
   RTO.Beta - 1/4
   Valid.Cookie.Life - 60 seconds
   Association.Max.Retrans - 10 attempts
   Path.Max.Retrans - 5 attempts (per destination address)
   Max.Init.Retransmits - 8 attempts
   HB.interval - 30 seconds
   HB.Max.Burst - 1
   SACK.Delay - 200 milliseconds
</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The parameter was given a name and added to the list of protocol
parameters.</t>
</section>
</section>

<section title='Window Updates After Window Opens Up'>
<section title='Description of the Problem'>
<t>The transmittal of unsolicited window updates is only indirectly referenced
in <xref target="RFC4960"/>, Section 6.2, where it is stated that an SCTP
receiver must not generate more than one SACK for every incoming packet, other
than to update the offered window. However, sending of unsolicited opening
window updates when the window opens up may really help to avoid deadlock
situations and to effectively resume traffic after closer of rwnd.   
</t>
</section>
<section title='Text Changes to the Document'>
<figure>
<artwork>
---------
Old text: (Section 6.2)
---------

An SCTP receiver MUST NOT generate more than one SACK for every
incoming packet, other than to update the offered window as the
receiving application consumes new data.

---------
New text: (Section 6.2)
---------

An SCTP receiver MUST NOT generate more than one SACK for every
incoming packet, other than to update the offered window as the
receiving application consumes new data. When the window opens
up, an SCTP receiver MAY periodically send additional SACK chunks
to update the window unless new data is received.

</artwork>
</figure>
</section>
<section title='Solution Description'>
<t>The new text makes clear that additional SACK chunks may be sent
to update the window more effectively.</t>
</section>
</section>

</section>

<section title='IANA Considerations'>
<t>This documents does not require any actions from IANA.</t>
</section>

<section title='Security Considerations'>
<t>This document does not add any security considerations to those given
in <xref target="RFC4960"/>.</t>
</section>

<section title="Acknowledgments">
<t>The authors wish to thank
Pontus Andersson,
Eric W. Biederman,
Cedric Bonnet,
Lionel Morand,
Jeff Morriss,
Karen E. E. Nielsen,
Tom Petch
and
Julien Pourtet
for their invaluable comments.</t>
</section>

</middle>

<back>
<references title='Normative References'>
<?rfc include="reference.RFC.2119" ?>
<?rfc include="reference.RFC.4960" ?>
</references>
<references title='Informative References'>
<?rfc include="reference.RFC.2960" ?>
<?rfc include="reference.RFC.4460" ?>
<?rfc include="reference.RFC.5681" ?>
</references>
</back>
</rfc>
